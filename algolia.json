[{"objectID":"1745228518","permalink":"/post/doublelinkedlist/","title":"C语言实现双向链表：创建、插入与删除操作","content":"在这篇博客中，我们将深入探讨如何用 C 语言实现一个双向链表。我们将逐步实现双向链表的基本操作，包括节点的增、删、查、遍历等，并解释相关的概念与代码实现。与普通链表相比，双向链表的每个节点包含两个指针域：一个指向前一个节点，另一个指向下一个节点，从而使得操作变得更加灵活。\n什么是双向链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而双向链表的特点是： 双向链表中，每个节点不仅包含指向下一个节点的指针，还包含指向前一个节点的指针。这使得双向链表可以在两个方向上进行遍历。 双向链表非常适用于需要在两个方向遍历的数据结构，例如浏览器的前进/后退按钮、双向队列等。 设计双向链表 为了实现双向链表，我们首先需要定义一个链表节点的结构体（DoubleLinkedList_t）。该结构体包含三个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 prev：指向前一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的双向链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : DoubleLinkedList.c * @brief : 实现双向链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/21 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要实现一个函数来创建一个空的双向链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向 NULL，表示链表为空。\n/** * @name DoubleLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/19 * @version 1.0 * @note 返回初始化的头结点 */ DoubleLinkedList_t * …","date":"2025-04-21 17:41:58","updated":"2025-04-21 17:41:58"},{"objectID":"1745228518","permalink":"/post/doublecirlinkedlist/","title":"C语言实现双向循环链表：创建、插入与删除操作","content":"在数据结构中，链表是基础而重要的一部分，而双向链表和循环链表则在一些特定场景下提供了更多灵活性和高效性。今天，我们将探讨如何使用 C 语言实现一个双向循环链表，并实现其基本操作：创建链表、插入节点、删除节点、遍历等。\n双向循环链表的定义 双向链表每个节点都包含三个部分：\n数据域：存储实际数据。 前驱指针：指向当前节点的前一个节点。 后继指针：指向当前节点的下一个节点。 循环特性则意味着链表的尾节点的后继指针指向头节点，头节点的前驱指针指向尾节点。这种结构使得从任意一个节点开始都可以进行完整的遍历。\n/** * @file name : DoubleCircularLinkedList.c * @brief : 实现双向循环链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/23 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要定义链表节点的数据结构。每个节点将包含数据域、前驱指针和后继指针。\n// 单向链表的数据类型 typedef int DataType_t; // 构造链表的节点 typedef struct DoubleCirLinkedList { DataType_t data; // 节点的数据域 struct DoubleCirLinkedList *prev; // 直接前驱的指针域 struct DoubleCirLinkedList *next; // 直接后继的指针域 } DoubleCirLinkedList_t; 我们首先定义一个函数来创建一个空链表并初始化头结点。头结点的 next 和 prev 都指向自己，体现了链表的循环特性。\n/** * @name DoubleCirLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/23 * @version 1.0 * @note 返回初始化的头结点 */ DoubleCirLinkedList_t * …","date":"2025-04-21 17:41:58","updated":"2025-04-21 17:41:58"},{"objectID":"1745055718","permalink":"/post/circularlinkedlist/","title":"C语言实现单向循环链表：创建、插入与删除操作","content":"在本篇博客中，我们将深入探讨如何用 C 语言实现一个单向循环链表。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 next 指针指向的是头节点，从而形成了一个闭环。\n什么是循环链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而循环链表的特点是：\n单向循环链表中，最后一个节点的 next 指针不指向 NULL，而是指向头节点。也就是说，遍历链表时，最后会回到头节点，形成一个闭环。 循环链表非常适用于需要重复遍历的数据结构，比如缓冲区、任务调度等。 设计单向循环链表 为了实现单向循环链表，我们首先需要定义一个链表节点的结构体（CircLList_t）。该结构体包含两个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的单向循环链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : CircularLinkedList.c * @brief : 实现单向循环链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/18 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建单向循环链表 首先，我们需要实现一个函数来创建一个空的单向循环链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向自己，表示链表为空。\n/** * @name CircularLinkedList_Create * @brief 创建一个空单项循环链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/18 * @version 1.0 * @note */ CircularLinkedList * …","date":"2025-04-19 17:41:58","updated":"2025-04-19 17:41:58"},{"objectID":"1744710118","permalink":"/post/linkedlist/","title":"用 C 语言实现单向链表","content":"在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。\n版本：\n链表基础知识 链表是一种数据结构，它由一系列节点（Node）构成，每个节点包含两个部分：\n数据域（Data）：存储实际的数据。 指针域（Next）：指向下一个节点的指针。 单向链表 单向链表是最简单的链表形式，每个节点只有一个指针域，指向下一个节点。最后一个节点的指针域为空（NULL），表示链表的结尾。\n实现单向链表 我们将实现以下几个功能：\n链表创建：创建一个空的链表。 节点插入：支持头部插入、尾部插入和指定位置插入。 节点删除：删除链表中的指定节点。 查找节点：查找链表中是否包含指定数据的节点。 更新节点：修改链表中指定节点的数据。 遍历链表：遍历并打印链表中的所有节点。 /** * @file name : LinkedList.c * @brief : 实现链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/09 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 链表创建 链表的创建首先需要创建一个头节点。头节点不存储实际数据，但它是链表的起点，所有的操作都需要从头节点开始。我们使用 calloc 动态分配内存来创建头节点。\n/** * @name LinkedList_Create * @brief 创建一个空链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/09 * @version 1.0 * @note */ LinkedList_t *LinkedList_Create(void) { //给头结点申请一片内存 LinkedList_t * head = (LinkedList_t *)calloc(1,sizeof(LinkedList_t)); //错误处理 if (head == NULL) { …","date":"2025-04-15 17:41:58","updated":"2025-04-15 17:41:58"},{"objectID":"1744191718","permalink":"/post/sequencelist/","title":"数据结构-顺序表的增、删、改、查（C语言版）","content":"顺序表是数据结构中最基本的一种线性表，它以一段连续的存储空间来存储数据元素，元素之间的顺序由它们在内存中的位置来决定。在C语言中，我们通常使用数组来实现顺序表。\n版本：\n/** * @file name : SequenceList.c * @brief : 实现顺序表元素的增删改查 * @author : qrshxc@163.com * @date : 2025/04/07 * @version : 1.0 * @note : 模块化实现 * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 顺序表的结构定义 首先，我们需要定义一个结构体来表示顺序表，包括数据类型和数据表各项参数等信息：\ntypedef int DataType_t; //构造顺序表SquenceList各项参数（顺序表的首地址，容量大小，有效元素最后的下标） typedef struct SequenceList { DataType_t *addr;//记录顺序表首元素地址 unsigned int size;//记录顺序表容量大小 int last;//记录顺序表有效元素最后下标 }SeqList_t; 创建一个空顺序表 创建顺序表并对顺序表进行初始化\n/** * @name SeqList_create * @brief 创建顺序表并对顺序表进行初始化 * @param size 顺序表的大小 * @return * @retval manager 顺序表的管理结构体 * @date 2025/04/07 * @version 1.0 * @note Manager-\u0026amp;gt;Addr ---\u0026amp;gt; [Size*sizeof(DataType_t)] */ SeqList_t *SeqList_create(unsigned size) { // 1.利用calloc给管理结构体manager申请一块堆内存 SeqList_t *manager = (SeqList_t *)calloc(1,sizeof(SeqList_t)); //错误处理 if(manager == NULL){ perror(\u0026amp;#34;calloc memory for manager is failed!\u0026amp;#34;); …","date":"2025-04-09 17:41:58","updated":"2025-04-09 17:41:58"}]