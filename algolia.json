[{"objectID":"1752831718","permalink":"/post/fileioday3/","title":"文件IO第三天知识","content":"练习：设计程序，实现在开发板的LCD 屏幕显示三种颜色，拓展：在开发板的LCD 上画一个圆\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { // 1. 打开LCD设备文件 int lcd_fd = open(\u0026#34;/dev/fb0\u0026#34;, O_RDWR); // 修正设备路径为/dev/fb0 if (-1 == lcd_fd) { perror(\u0026#34;open lcd error\u0026#34;); // 使用perror输出更详细的错误信息 exit(1); } // 2. 准备颜色数据并写入LCD int colorbuf[800*480] = {0}; // 800x480分辨率，每个像素4字节 // 分段填充颜色 int i = 0; for (; i \u0026lt; 800*160; ++i) { // 顶部160行黑色 colorbuf[i] = 0x00000000; } for (; i \u0026lt; 800*320; ++i) { // 中间160行红色 colorbuf[i] = 0x00FF0000; } for (; i \u0026lt; 800*480; ++i) { // 底部160行黄色 colorbuf[i] = 0x00FFFF00; } // 写入LCD设备 ssize_t ret = write(lcd_fd, colorbuf, 800*480*4); if (ret == -1) { perror(\u0026#34;write to LCD failed\u0026#34;); close(lcd_fd); exit(1); } // 3. 关闭LCD设备 close(lcd_fd); return 0; } 在开发板的LCD 上画一个圆\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WIDTH 800 // 屏幕宽度 #define HEIGHT 480 // 屏幕高度 #define CENTER_X 400 // 圆心X坐标 #define CENTER_Y 240 // 圆心Y坐标 #define RADIUS 10 // 圆半径 int main() { // 1. 打开FrameBuffer设备 int fb_fd = open(\u0026#34;/dev/fb0\u0026#34;, O_RDWR); if (fb_fd == -1) { perror(\u0026#34;Failed to open framebuffer\u0026#34;); return 1; } // 2. 映射帧缓冲内存 unsigned int *fb_map = mmap(NULL, WIDTH*HEIGHT*4, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0); if (fb_map == MAP_FAILED) { perror(\u0026#34;Failed to mmap framebuffer\u0026#34;); close(fb_fd); return 1; } // 3. 绘制圆形（红色） for (int y = CENTER_Y - RADIUS; y \u0026lt;= CENTER_Y + RADIUS; y++) { for (int x = CENTER_X - RADIUS; x \u0026lt;= CENTER_X + RADIUS; x++) { // 检查像素是否在圆内（圆方程：(x-a)² + (y-b)² ≤ r²） if ((x - CENTER_X)*(x - CENTER_X) + (y - CENTER_Y)*(y - CENTER_Y) \u0026lt;= RADIUS*RADIUS) { // 确保坐标在屏幕范围内 if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; WIDTH \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; HEIGHT) { fb_map[y * WIDTH + x] = 0x00FF0000; // ARGB格式的红色 } } } } // 4. 解除映射并关闭设备 munmap(fb_map, WIDTH*HEIGHT*4); close(fb_fd); return 0; } 练习：设计程序，利用ioctl 函数获取LCD 的硬件参数，把LCD 屏幕的宽和高以及色深的位数输出到屏幕，下载程序到开发板并进行验证。提示：必须包含该头文件\u0026lt;linux/fb.h\u0026gt; !!!!\n#include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;linux/fb.h\u0026gt; int main(int argc, char const *argv[]) { //1.打开LCD int lcd_fd = open(\u0026#34;/dev/fbb\u0026#34;,0_RDWR); //2.利用ioctl函数获取LCD硬件参数 struct fb_var_screeninfo lcd_vinfo; ioctl(lcd_fd,FBIOGET_VSCREENINFO,\u0026amp;led_vinfo); //3.输出LCD的宽、高 printf(\u0026#34;led_height = %d\\n\u0026#34;, lcd_vinfo.vres); //480 printf(\u0026#34;led width = %d\\n\u0026#34;, lcd_vinfo.xres); //800 return 0; } ","date":"2025-07-18 17:41:58","updated":"2025-07-18 17:41:58"},{"objectID":"1752831718","permalink":"/post/fileioday4/","title":"文件IO第四天知识","content":"练习：设计程序，利用系统IO 函数实现让开发板的LCD 屏填充为三色国旗，要求使用内存映射的方式实现，程序设计完成后下载到开发板进行验证并观察效果。\n//假设让LCD显示红色,这个程序需要在开发板中运行 需要交叉编译 arm-linux-gcc #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; int main(int argc, char const *argv[]) { //1.打开LCD 设备文件路径 \u0026#34;/dev/fb0\u0026#34; O_RDWR int lcd_fd = open(\u0026#34;/dev/fb0\u0026#34;,O_RDWR); if (-1 == lcd_fd) { printf(\u0026#34;open lcd error\\n\u0026#34;); return -1; } //2.对LCD进行内存映射 mmap函数 记得接收返回值 int *lcd_mp = (int *)mmap( NULL, 800*480*4, PROT_READ|PROT_WRITE, MAP_SHARED, lcd_fd, 0 ); if (MAP_FAILED == lcd_mp) { printf(\u0026#34;mmap for lcd is error\\n\u0026#34;); return -1; } //3.把颜色分量写入到申请的映射内存空间中，通过地址偏移实现访问 for (int i = 0;i \u0026lt; 800*480; ++i) { lcd_mp[i] = 0x00FF0000; } //4.关闭LCD并解除内存映射 munmap(lcd_mp,800*480*4); close(lcd_fd); return 0; } 练习：设计程序，利用系统IO 读取磁盘上指定BMP 图片的宽和高，以及BMP 图片的大小，并输出到终端，要求图片名称通过命令行传递。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #pragma pack(1) // 禁止内存对齐填充 typedef struct { unsigned short type; // 2字节，\u0026#34;BM\u0026#34;标识 unsigned int size; // 4字节，文件总大小 unsigned short reserved1;// 2字节，保留 unsigned short reserved2;// 2字节，保留 unsigned int offset; // 4字节，数据偏移量 } BMPFileHeader; // 总计14字节 typedef struct { unsigned int header_size; // 4字节，信息头大小(40) int width; // 4字节，图像宽度 int height; // 4字节，图像高度 unsigned short planes; // 2字节，颜色平面数 unsigned short bpp; // 2字节，每像素位数 unsigned int compression; // 4字节，压缩类型 unsigned int image_size; // 4字节，图像数据大小 int x_ppm; // 4字节，水平分辨率 int y_ppm; // 4字节，垂直分辨率 unsigned int colors; // 4字节，颜色数 unsigned int important_colors; // 4字节，重要颜色数 } BMPInfoHeader; // 总计40字节 #pragma pack() // 恢复默认对齐 int main(int argc, char *argv[]) { // 1. 验证参数 if (argc != 2) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;bmp_file\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // 2. 打开文件 int fd = open(argv[1], O_RDONLY); if (fd == -1) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } // 3. 读取文件头 BMPFileHeader fh; if (read(fd, \u0026amp;fh, sizeof(fh)) != 14) { perror(\u0026#34;Error reading file header\u0026#34;); close(fd); return 1; } // 4. 验证BMP格式 if (fh.type != 0x4D42) { // \u0026#34;BM\u0026#34;的十六进制 fprintf(stderr, \u0026#34;Not a valid BMP file\\n\u0026#34;); close(fd); return 1; } // 5. 读取信息头 BMPInfoHeader ih; if (read(fd, \u0026amp;ih, sizeof(ih)) != 40) { perror(\u0026#34;Error reading info header\u0026#34;); close(fd); return 1; } // 6. 输出结果 printf(\u0026#34;BMP File Information:\\n\u0026#34;); printf(\u0026#34; File Path: %s\\n\u0026#34;, argv[1]); printf(\u0026#34; File Size: %u bytes\\n\u0026#34;, fh.size); printf(\u0026#34; Dimensions: %d x %d pixels\\n\u0026#34;, ih.width, ih.height); // 7. 关闭文件 close(fd); return 0; } ","date":"2025-07-18 17:41:58","updated":"2025-07-18 17:41:58"},{"objectID":"1752572518","permalink":"/post/fileioday2/","title":"文件IO第二天知识","content":"练习：要求利用标准IO 函数接口实现计算一个本地磁盘某个文件的大小，要求文件名称通 过命令行进行传递，并进行验证是否正确( ls -l)。\n#include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;stdlib.h\u0026amp;gt; int main(int argc, char const *argv[]) { // 1.要求要计算大小的文件的路径需要通过命令行传递给main()，需要判断用户传递的参数是否有效 if (2 != argc) { printf(\u0026amp;#34;argument is invalid!\\n\u0026amp;#34;); exit(1); } // 2.利用fopen()以只读方式打开需要计算大小的文件 \u0026amp;#34;rb\u0026amp;#34; 以二进制方式打开文件 FILE *fp = fopen(argv[1], \u0026amp;#34;rb\u0026amp;#34;); if (NULL == fp) { perror(\u0026amp;#34;fopen file error\u0026amp;#34;); exit(1); } // 3.计算文本数据大小，可以采用循环计数的方式，每次从文本中读取一个字符，直到文本到达末尾 int cnt = 0; while (1) { if (fgetc(fp) == EOF) { printf(\u0026amp;#34;end of file\\n\u0026amp;#34;); break; } cnt++; } // 4.循环终止，则说明计算完成，此时输出文本大小即可 // printf(\u0026amp;#34;file [%s]: size = %ld \\n\u0026amp;#34;, argv[1], ftell(fp)); // 第二种方法，简单 printf(\u0026amp;#34;file [%s]: size = %d \\n\u0026amp;#34;, argv[1], cnt); // 5.关闭文件 fclose(fp); return 0; } 练习：利用标准IO 函数接口实现文件拷贝，把本地磁盘的文件A 中的数据完整的拷贝到另 一个文本B 中，如果文本B 不存在则创建，要求文本A 的名称和文本B 的名称通过命令行 传递，并进行验证是否正确。\n#include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;strings.h\u0026amp;gt; #include \u0026amp;lt;stdlib.h\u0026amp;gt; //用户缓冲区的大小 #define BUFFERSIZE …","date":"2025-07-15 17:41:58","updated":"2025-07-15 17:41:58"},{"objectID":"1752399718","permalink":"/post/fileioday1/","title":"文件IO第一天知识","content":"练习：在本地磁盘打开一个存储少量数据的文本demo.txt，利用fgetc 函数把文本中的字符 输出到屏幕，当文本中所有字符都输出完成后就结束程序。\n#include \u0026lt;stdio.h\u0026gt; /** * @name :main * @brief :程序主入口，演示文件读取操作 * @param :argc 命令行参数个数 * @param :argv 命令行参数数组 * @return :程序执行状态(0表示成功，-1表示失败) * @date :2025/07/13 * @version :1.0 * @note :该程序打开demo.txt文件并输出其内容到终端 */ int main(int argc, char const *argv[]) { // 1.打开demo.txt FILE *file = fopen(\u0026#34;demo.txt\u0026#34;, \u0026#34;r\u0026#34;); if (NULL == file) { perror(\u0026#34;open demo.txt error\u0026#34;); return -1; } // 2.循环读取文本的字符串输出到终端 int ch = fgetc(file); while (ch != EOF) { printf(\u0026#34;%c\u0026#34;, ch); // 输出已经获取的字符 ch = fgetc(file); } printf(\u0026#34;\\n\u0026#34;); // 3.关闭demo.txt fclose(file); return 0; } 练习：编写一个程序，检测标准IO 的缓冲区的大小。提示：普通文件默认是全缓冲，可以 利用这个特性，一个字节一个字节写入数据，并且在每次写入数据之后获取文件的大小，直 到把缓冲区填满即可测得缓冲区的大小，获取文件信息的函数是stat()。\n/** * @file name : io_buffer_size.c * @brief : 检测标准IO缓冲区大小 * @author : qrshxc@163.com * @date : 2025/07/13 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; /** * @name get_file_size * @brief 获取文件大小 * @param filename 文件名 * @return 文件大小(字节数)，出错返回-1 * @date 2025/07/18 * @version 1.0 * @note 使用stat()函数获取文件信息 */ long get_file_size(const char *filename) { struct stat st; if (stat(filename, \u0026amp;st) == -1) { perror(\u0026#34;stat failed\u0026#34;); return -1; } return st.st_size; } /** * @name detect_buffer_size * @brief 检测标准IO缓冲区大小 * @param filename 测试文件名 * @return 缓冲区大小(字节数)，出错返回-1 * @date 2025/07/13 * @version 1.0 * @note 通过逐个字节写入文件并观察文件大小变化确定缓冲区大小 */ int detect_buffer_size(const char *filename) { FILE *fp = fopen(filename, \u0026#34;w\u0026#34;); if (!fp) { perror(\u0026#34;fopen failed\u0026#34;); return -1; } // 删除可能已存在的文件 unlink(filename); long prev_size = 0; int buffer_size = 0; // 逐个字节写入，直到文件大小变化 for (int i = 1; ; i++) { fputc(\u0026#39;a\u0026#39;, fp); fflush(fp); // 确保写入操作完成 long curr_size = get_file_size(filename); if (curr_size == -1) { fclose(fp); return -1; } if (curr_size \u0026gt; prev_size) { if (prev_size == 0) { // 第一次写入，缓冲区为空 prev_size = curr_size; } else { // 文件大小变化，说明缓冲区已满 buffer_size = i - 1; break; } } } fclose(fp); unlink(filename); // 删除测试文件 return buffer_size; } int main() { const char *test_file = \u0026#34;buffer_test.tmp\u0026#34;; int size = detect_buffer_size(test_file); if (size \u0026gt; 0) { printf(\u0026#34;Standard IO buffer size: %d bytes\\n\u0026#34;, size); } else { printf(\u0026#34;Failed to detect buffer size\\n\u0026#34;); } return 0; } ","date":"2025-07-13 17:41:58","updated":"2025-07-13 17:41:58"},{"objectID":"1746783718","permalink":"/post/bstest/","title":"C语言——数据结构二叉树笔试题","content":"假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有叶子结点数\n/** * @name BinaryTree_CountLeafNode * @brief 计算一棵给定二叉树的所有叶子结点数 * @param root 根节点 * @return\tleftCount + rightCount 叶子结点数 * @retval * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_CountLeafNode(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { // 空树 return 0; }else if ( root-\u0026gt;lchild == NULL \u0026amp;\u0026amp; root-\u0026gt;rchild ==NUll ) { // 只有一个根结点 return 1; }else { int leftCount = BinaryTree_CountLeafNode(root-\u0026gt;lchild); // 左子树的叶子结点数 int rightCount = BinaryTree_CountLeafNode(root-\u0026gt;rchild); // 右子树的叶子结点数 } return leftCount + rightCount; } 假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有结点数\n/** * @name BinaryTree_CountNode * @brief 假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有叶子结点数 * @param root 根结点 * @return * @retval leftCount + rightCount +1 结点数 * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_CountNode(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { return 0; } int leftCount = BinaryTree_CountNode(root-\u0026gt;lchild); // 左子树的叶子结点数 int rightCount = BinaryTree_CountNode(root-\u0026gt;rchild); // 右子树的叶子结点数 return leftCount + rightCount + 1; } 写一个算法求一棵二叉树的深度二叉树以二叉链表为存储方式。\n/** * @name BinaryTree_GetDepth * @brief 求一棵二叉树的深度二叉树以二叉链表为存储方式 * @param root 根节点 * @return\t(leftCount \u0026gt; rightCount ? leftCount : rightCount) + 1 深度 * @retval * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_GetDepth(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { // 空树 return 0; }else { int leftCount = BinaryTree_CountLeafNode(root-\u0026gt;lchild); // 左子树深度 int rightCount = BinaryTree_CountLeafNode(root-\u0026gt;rchild); // 右子树深度 } return (leftCount \u0026gt; rightCount ? leftCount : rightCount) + 1; } ","date":"2025-05-09 17:41:58","updated":"2025-05-09 17:41:58"},{"objectID":"1746783718","permalink":"/post/stacktoqueue/","title":"C语言笔试题:利用两个栈s1和s2来模拟一个队列","content":"请利用两个栈s1和s2来模拟一个队列，假设栈中元素为int 型，栈中元素最多为 maxSizc。入队:栈的3个运算定义如下。 push(ST,x):元素x入 ST 栈。 pop(ST,\u0026amp;x):ST栈顶元素出栈，赋给变量x。 isEmpty(ST):判断 ST 栈是否为空。 如何利用栈的运算来实现该队列的3个运算:enQueue(元素入队列)、deQueue(元素出队列)、isQueueEmpty(判断队列是否为空，空返回1，不空返回0)。\n// 利用栈s1和s2模拟一个队列，栈的思想是先进后出，队列的思想是后进先出，可以把s1作为入队，s2作为出队 // 入队 bool Enqueue(s1,s2,int x) { int temp; // 用于存储出栈元素的值 // 判断s1是否已满，此时分两种情况（满 or 不满） if( s1-\u0026gt;top + 1 == maxSizc ) { // s1已满，此时有两种情况（栈s2空 or 栈s2不空） // 1.栈s2空 if ( isEmpty(s2) ) { // 把栈s1元素依次入栈s2 while(!isEmpty(s1)) { pop(s1,\u0026amp;temp); // 把栈s1元素暂存temp中 push(s2,temp); // 把temp中的元素入栈到s2 } push(s1,x); // 入栈到s1 return true; }else // 2.栈s2不空 { return false; } }else // 栈s1不满 { push(s1,x); // 直接把x入栈到s1 } return true; } // 出队 bool Dequeue(s1,s2,\u0026amp;x) { int temp; // 用于存储出栈元素 // 判断队列是否为空，此时分两种情况（空 or 不空） if ( isQueueEmpty(s1,s2) ) { return false; }else { // 队列不空，此时分两种情况（栈s2空 or 栈s2不空） if ( !isEmpty(s2) ) { pop(s2,\u0026amp;x); }else { while(!isEmpty(s1)) { pop(s1,\u0026amp;temp); push(s2,temp); } pop(s2,\u0026amp;x) } } return true; } ","date":"2025-05-09 17:41:58","updated":"2025-05-09 17:41:58"},{"objectID":"1746610918","permalink":"/post/test/","title":"C语言——数据结构笔试题","content":"\n已知一个顺序表工，其中的元素递增有序排列，设计一个算法，插入一个元素x(x为int型)后保持该顺序表仍然递增有序排列(假设插入操作总能成功)。\n// 递增排序插入 void SeqList_Insert(SeqList *L, int x) { int temp = -1; // 记录待插入元素的下标 // 遍历顺序表，找到插入位置，比较元素 for (int i = 0; i \u0026lt;= last; ++i) { if (x \u0026lt; L[i]) { temp = i; break; } } if (-1 == temp) { L[last+1] = x; return; } // 把待插入位置的后继元素向后移动 for (int i = last; i \u0026gt;= temp; i--) { L[i+1] = L[i]; } L[temp] = x; // 插入当前位置 } 删除顺序表工中下标为p(0\u0026lt;p\u0026lt;length-1)的元素，成功返回1，否则返回 0，并将被删除元素的值赋给 e。\nint SeqList_Remove(*L, int p) { // 判断L地址是否有效 if( L == NULL ) { return 0; } // 备份待删除元素的值到e中 int e = L[p] // 把待删除元素的后继元素向前移动1单位 for(int i = p;i \u0026lt; length;i++) { L[i] = L[i+1] } return 1; } 设计一个算法删除单链表L(有头结点)中的一个最小值结点\nbool LinkedList_DelMinVal(LinkedList_t *head) { // 判断链表是否为空（只有头结点） if (head == NULL || head-\u0026gt;next == NULL) { return false; } LinkedList_t *prev = head; // 当前结点的前驱 LinkedList_t *current = head-\u0026gt;next; // 当前结点 LinkedList_t *minPrev = prev; // 最小值结点的前驱 LinkedList_t *minNode = current; // 最小值结点 // 遍历链表寻找最小值结点 while (current != NULL) { if (current-\u0026gt;data \u0026lt; minNode-\u0026gt;data) // 比较结点值 { minNode = current; minPrev = prev; } prev = current; current yyyyyyent-\u0026gt;next; } // 删除最小值结点 minPrev-\u0026gt;next = minNode-\u0026gt;next; minNode = NULL; free(minNode); return true; } 1.已知一个带有表头结点的单链表，结点结构为: datanext假设该链表只给出了头指针 head。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k(k为正整数)个位置上的结点。若查找成功，算法输出该结点的data值，并返回 1:否则，只返回 0。\nint findKthToLast(ListNode *head, int k) { // 判断链表是否为空（只有头结点） if (head == NULL || head-\u0026gt;next == NULL) { return 0; } ListNode *p = head; // 慢指针 ListNode *q = head; // 快指针 // 快指针先移动k步 for (int i = 0; i \u0026lt; k; i++) { if (q == NULL) { // 链表长度小于k return 0; } q = q-\u0026gt;next; } // 同时移动两个指针 while (q != NULL) { p = p-\u0026gt;next; q = q-\u0026gt;next; } printf(\u0026#34;倒数第%d个结点的data值为: %d\\n\u0026#34;, k, p-\u0026gt;data); return 1; } ","date":"2025-05-07 17:41:58","updated":"2025-05-07 17:41:58"},{"objectID":"1745833318","permalink":"/post/circularqueue/","title":"C语言循环队列的实现与分析","content":" 引言 队列（Queue）和栈类似，相同点是都属于线性结构，不同点是栈遵循“后进先出”原则，而队列遵循“先进先出”的原则，也被成为“FIFO”结构，就是“First Input First Output”\n数据结构中的队列的两端都允许操作，只不过要求数据只能从队列的一端插入，从队列的另一端删除，可以把队列理解为一根水管，水管有进水口和出水口。一般把允许数据插入的一端称为队尾（Tail或者Rear），一般把允许删除数据的一端称为队头队首（Head或者Front）。\n把允许数据插入的一端称为队尾（允许数据插入到队列的操作称为入队，英文enqueue） 把允许删除数据的一端称为队头（允许数据从队列删除的操作称为出队，英文dequeue） 队列也属于线性结构，所以根据数据元素之间的物理关系来划分的话同样可以以数组或者链表为基础来实现队列的操作。\n以数组为基础实现循环队列 如果以数组为基础，一般会把队列设置为循环队列，循环队列也被称为“环形缓冲区”，因为如果队列中的元素出队，则需要把该元素的后继元素整体向前移动，这是时间复杂度为O(n)的操作。\n如果数据出队之后不去移动后继元素又会导致数组的空间被浪费，为了解决该问题，可以把队列设置为循环队列，在移动数据的时候只需要移一次即可，所以时间复杂度就是O(1)。\n1. 定义数据类型与队列结构 1.1 数据类型定义 循环队列的元素类型可以根据需要进行更改。在此示例中，我们将队列的数据类型定义为 int，并且可以根据需求将其更改为其他类型，如 float 或 char。\n// 循环队列的数据类型 typedef int DataType_t; 1.2 队列结构体定义 我们需要定义一个结构体来管理循环队列的相关信息，包括队列的数据存储、队列的容量、队头和队尾指针。结构体 CirQueue_t 将包含以下成员：\naddr：指向存储数据的数组。 size：队列的最大容量。 rear：队尾指针，指向下一个入队位置。 front：队首指针，指向当前出队的位置。 // 构造循环队列的各项参数（首地址，容量大小，队尾下标，队首下标） typedef struct CircularQueue { DataType_t *addr; // 记录循环队列首元素地址 unsigned int size; // 记录循环队列容量大小 int rear; //  …","date":"2025-04-28 17:41:58","updated":"2025-04-28 17:41:58"},{"objectID":"1745660518","permalink":"/post/seqisstrvail/","title":"笔试题：C语言使用顺序栈判断字符串中的括号有效性","content":" 一、背景介绍 通过键盘输入一个包括 \u0026amp;lsquo;(\u0026amp;rsquo; 和 \u0026amp;lsquo;)\u0026amp;rsquo; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。\n我们可以利用 顺序栈（Sequence Stack）来解决这个问题，因为栈结构可以有效地跟踪括号的匹配关系。顺序栈是一个静态实现的栈数据结构，它通过数组实现栈的各项操作，具有较高的时间和空间效率。\n本文将介绍如何使用顺序栈来判断括号是否有效，以下是解决该问题的详细步骤。\n二、算法设计 解决括号匹配问题的基本思路如下：\n入栈操作： 当遇到左括号 ( 时，将其压入栈中。 出栈操作： 当遇到右括号 ) 时，从栈中弹出栈顶元素。 如果栈为空，表示没有对应的左括号，返回无效。 如果弹出的栈顶元素是左括号 (，继续判断下一个字符。 结束后检查栈是否为空： 如果栈不为空，说明有未匹配的左括号，返回无效。 如果栈为空，表示所有括号均有效，返回有效。 版本：\n/** * @file name : SeqenceIsStrVaild.c * @brief : 通过键盘输入一个包括 \u0026amp;#39;(\u0026amp;#39; 和 \u0026amp;#39;)\u0026amp;#39; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。 * @author : qrshxc@163.com * @date : 2025/04/26 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 三、顺序栈的实现 顺序栈是一种通过数组实现的栈数据结构，通常需要维护三个基本操作：入栈、出栈、检查栈是否为空。\n1. 顺序栈的定义 我们首先定义顺序栈的结构体 SeqStack_t，包括栈底指针、栈容量和栈顶指针。\nc复制编辑typedef char DataType_t; // 栈数据类型 // …","date":"2025-04-26 17:41:58","updated":"2025-04-26 17:41:58"},{"objectID":"1745574118","permalink":"/post/seqstack/","title":"笔试题：C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数","content":" 一、背景介绍 栈是一种特殊的线性表，特殊在栈的一端是封闭的，数据的插入与删除只能在栈的另一端进行，也就是栈遵循“后进先出”的原则。也被成为“LIFO”结构，意思是“last input first output”。\n栈（stack）,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈（PUSH）、出栈（POP）的说法。\n栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。\n闭合的一端被称为栈底（Stack Bottom），允许数据的插入与删除的一端被称为栈顶（Stack Top），不包含任何元素的栈被称为空栈。\n把数据插入到栈空间的动作被称为入栈或者压栈 从栈空间中删除数据的动作被称为出栈或者弹栈 由于栈也是一种线性结构，所以可以以数组或者链表作为基础，在此基础上实现栈的操作。\n以数组作为基础实现栈空间（顺序栈）\n数组在内存中占用一块连续的空间，也就是数组元素的内存地址是连续的。为了实现栈，一般是把数组头作为栈底，数组头部到数组尾部作为栈的增长方向，也就是用户只在数组尾部对数据进行插入和删除。\n以链表作为基础实现栈空间（链式栈）\n如果打算实现链式栈，一般是以链表作为基础，一般是把链表头部作为栈顶，方便数据的插入和删除（头插+头删），链式栈相当于是一个单向不循环的链表。\n本篇博客将展示如何使用顺序栈实现以下功能：\n顺序栈的实现：创建栈、判断栈满与栈空、栈的入栈与出栈操作等。 进制转换：通过栈来实现将十进制数转换为十六进制数。 二、顺序栈的实现 顺序栈使用数组来实现，它包含以下基本操作：\n入栈：将元素压入栈顶。 出栈：从栈顶弹出元素。 判断栈是否为空：栈空时返回true，否则返回false。 判断栈是否满：栈满时返回true，否则返回false。 首先，我们来看看顺序栈的结构和各个操作的实现。\n版本：\n/** * @file name : SequenceStack.c * @brief : C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数 * @author : qrshxc@163.com * @date : 2025/04/24 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 …","date":"2025-04-25 17:41:58","updated":"2025-04-25 17:41:58"},{"objectID":"1745574118","permalink":"/post/bstree/","title":"用 C 语言实现二叉查找树（BST）：插入与遍历","content":"二叉查找树（Binary Search Tree, BST）是一种在查找、插入、删除操作方面效率较高的基础数据结构。它广泛应用于各种算法与系统中，如数据库索引、集合容器等。\n本文将使用 C 语言实现一个完整的 BST，并支持以下功能：\n创建树 插入节点 前序 / 中序 / 后序遍历 项目说明与设计目标 /** * @file name : BST.c * @brief : 设计一个BST二叉查找树，为了方便对二叉树进行增删，所以采用双向不循环链表， * 每个节点的内部都需要有两个指针，分别指向该节点的左子树（lchild）和右子树（rchild） * @author : qrshxc@163.com * @date : 2025/05/08 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 说明： 该程序实现了 BST 的基本结构与插入功能，数据结构设计为每个节点包含一个整型键值，以及两个指向左右子树的指针，便于实现递归插入与遍历操作。\n数据结构定义 // BST树中结点有效键值的数据类型 typedef int DataType_t; // 构造BST树中的结点 typedef struct BSTreeNode { DataType_t data; // 结点的键值 struct BSTreeNode *lchild; // 左子树的指针域 struct BSTreeNode *rchild; // 右子树的指针域 } BSTree_t; 说明：\ndata：当前节点的键值（本例为整型） lchild：指向左子树的指针 rchild：指向右子树的指针 创建节点函数 创建根节点 /** * @name BSTree_Create * @brief 创建一个带键值的根结点，并进行初始化 * @param data 节点的键值 * @return * @retval root 根节点 * @date 2025/05/08 * @version 1.0 * @note */ BSTree_t * BSTree_Create(DataType_t data) { // 给根结点申请一片内存 BSTree_t *root = (BSTree_t …","date":"2025-04-25 17:41:58","updated":"2025-04-25 17:41:58"},{"objectID":"1745401318","permalink":"/post/doublecirlinkedlist/","title":"C语言实现双向循环链表：创建、插入与删除操作","content":"在数据结构中，链表是基础而重要的一部分，而双向链表和循环链表则在一些特定场景下提供了更多灵活性和高效性。今天，我们将探讨如何使用 C 语言实现一个双向循环链表，并实现其基本操作：创建链表、插入节点、删除节点、遍历等。\n双向循环链表的定义 双向链表每个节点都包含三个部分：\n数据域：存储实际数据。 前驱指针：指向当前节点的前一个节点。 后继指针：指向当前节点的下一个节点。 循环特性则意味着链表的尾节点的后继指针指向头节点，头节点的前驱指针指向尾节点。这种结构使得从任意一个节点开始都可以进行完整的遍历。\n/** * @file name : DoubleCircularLinkedList.c * @brief : 实现双向循环链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/23 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要定义链表节点的数据结构。每个节点将包含数据域、前驱指针和后继指针。\n// 单向链表的数据类型 typedef int DataType_t; // 构造链表的节点 typedef struct DoubleCirLinkedList { DataType_t data; // 节点的数据域 struct DoubleCirLinkedList *prev; // 直接前驱的指针域 struct DoubleCirLinkedList *next; // 直接后继的指针域 } DoubleCirLinkedList_t; 我们首先定义一个函数来创建一个空链表并初始化头结点。头结点的 next 和 prev 都指向自己，体现了链表的循环特性。\n/** * @name DoubleCirLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/23 * @version 1.0 * @note 返回初始化的头结点 */ DoubleCirLinkedList_t * …","date":"2025-04-23 17:41:58","updated":"2025-04-23 17:41:58"},{"objectID":"1745228518","permalink":"/post/doublelinkedlist/","title":"C语言实现双向链表：创建、插入与删除操作","content":"在这篇博客中，我们将深入探讨如何用 C 语言实现一个双向链表。我们将逐步实现双向链表的基本操作，包括节点的增、删、查、遍历等，并解释相关的概念与代码实现。与普通链表相比，双向链表的每个节点包含两个指针域：一个指向前一个节点，另一个指向下一个节点，从而使得操作变得更加灵活。\n什么是双向链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而双向链表的特点是： 双向链表中，每个节点不仅包含指向下一个节点的指针，还包含指向前一个节点的指针。这使得双向链表可以在两个方向上进行遍历。 双向链表非常适用于需要在两个方向遍历的数据结构，例如浏览器的前进/后退按钮、双向队列等。 设计双向链表 为了实现双向链表，我们首先需要定义一个链表节点的结构体（DoubleLinkedList_t）。该结构体包含三个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 prev：指向前一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的双向链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : DoubleLinkedList.c * @brief : 实现双向链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/21 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要实现一个函数来创建一个空的双向链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向 NULL，表示链表为空。\n/** * @name DoubleLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/19 * @version 1.0 * @note 返回初始化的头结点 */ DoubleLinkedList_t * …","date":"2025-04-21 17:41:58","updated":"2025-04-21 17:41:58"},{"objectID":"1745055718","permalink":"/post/circularlinkedlist/","title":"C语言实现单向循环链表：创建、插入与删除操作","content":"在本篇博客中，我们将深入探讨如何用 C 语言实现一个单向循环链表。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 next 指针指向的是头节点，从而形成了一个闭环。\n什么是循环链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而循环链表的特点是：\n单向循环链表中，最后一个节点的 next 指针不指向 NULL，而是指向头节点。也就是说，遍历链表时，最后会回到头节点，形成一个闭环。 循环链表非常适用于需要重复遍历的数据结构，比如缓冲区、任务调度等。 设计单向循环链表 为了实现单向循环链表，我们首先需要定义一个链表节点的结构体（CircLList_t）。该结构体包含两个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的单向循环链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : CircularLinkedList.c * @brief : 实现单向循环链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/18 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建单向循环链表 首先，我们需要实现一个函数来创建一个空的单向循环链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向自己，表示链表为空。\n/** * @name CircularLinkedList_Create * @brief 创建一个空单项循环链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/18 * @version 1.0 * @note */ CircularLinkedList * …","date":"2025-04-19 17:41:58","updated":"2025-04-19 17:41:58"},{"objectID":"1744710118","permalink":"/post/linkedlist/","title":"用 C 语言实现单向链表","content":"在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。\n版本：\n链表基础知识 链表是一种数据结构，它由一系列节点（Node）构成，每个节点包含两个部分：\n数据域（Data）：存储实际的数据。 指针域（Next）：指向下一个节点的指针。 单向链表 单向链表是最简单的链表形式，每个节点只有一个指针域，指向下一个节点。最后一个节点的指针域为空（NULL），表示链表的结尾。\n实现单向链表 我们将实现以下几个功能：\n链表创建：创建一个空的链表。 节点插入：支持头部插入、尾部插入和指定位置插入。 节点删除：删除链表中的指定节点。 查找节点：查找链表中是否包含指定数据的节点。 更新节点：修改链表中指定节点的数据。 遍历链表：遍历并打印链表中的所有节点。 /** * @file name : LinkedList.c * @brief : 实现链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/09 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 链表创建 链表的创建首先需要创建一个头节点。头节点不存储实际数据，但它是链表的起点，所有的操作都需要从头节点开始。我们使用 calloc 动态分配内存来创建头节点。\n/** * @name LinkedList_Create * @brief 创建一个空链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/09 * @version 1.0 * @note */ LinkedList_t *LinkedList_Create(void) { //给头结点申请一片内存 LinkedList_t * head = (LinkedList_t *)calloc(1,sizeof(LinkedList_t)); //错误处理 if (head == NULL) { …","date":"2025-04-15 17:41:58","updated":"2025-04-15 17:41:58"},{"objectID":"1744191718","permalink":"/post/sequencelist/","title":"数据结构-顺序表的增、删、改、查（C语言版）","content":"顺序表指的是使用一组内存地址连续的内存单元来依次存储线性表中的数据元素，使用这种存储结构的线性表就被称为顺序表。\n简单理解：数据存储在一块连续的内存中，在C 语言中可以具名的数组，也可以使用匿名的数组（堆内存）。\n顺序表的特点：数据元素之间的逻辑关系是相邻的，并且内存地址也是相邻的，所以只要知道存储线性表的第一个数据元素的内存地址，就可以对线性表中的任意一个元素进行随机访问。通常用户使用动态分配的数组来实现顺序表,也就是使用堆内存实现。\n版本：\n/** * @file name : SequenceList.c * @brief : 实现顺序表元素的增删改查 * @author : qrshxc@163.com * @date : 2025/04/07 * @version : 1.0 * @note : 模块化实现 * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 顺序表的结构定义 首先，我们需要定义一个结构体来表示顺序表，包括数据类型和数据表各项参数等信息：\ntypedef int DataType_t; //构造顺序表SquenceList各项参数（顺序表的首地址，容量大小，有效元素最后的下标） typedef struct SequenceList { DataType_t *addr;//记录顺序表首元素地址 unsigned int size;//记录顺序表容量大小 int last;//记录顺序表有效元素最后下标 }SeqList_t; 创建一个空顺序表 创建顺序表并对顺序表进行初始化\n/** * @name SeqList_create * @brief 创建顺序表并对顺序表进行初始化 * @param size 顺序表的大小 * @return * @retval manager 顺序表的管理结构体 * @date 2025/04/07 * @version 1.0 * @note Manager-\u0026amp;gt;Addr ---\u0026amp;gt; [Size*sizeof(DataType_t)] */ SeqList_t *SeqList_create(unsigned size) { // 1.利用calloc给管理结构体manager申请一块堆内存 SeqList_t …","date":"2025-04-09 17:41:58","updated":"2025-04-09 17:41:58"}]