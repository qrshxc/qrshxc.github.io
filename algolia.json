[{"objectID":"1745833318","permalink":"/post/circularqueue/","title":"C语言循环队列的实现与分析","content":" 引言 队列（Queue）和栈类似，相同点是都属于线性结构，不同点是栈遵循“后进先出”原则，而队列遵循“先进先出”的原则，也被成为“FIFO”结构，就是“First Input First Output”\n数据结构中的队列的两端都允许操作，只不过要求数据只能从队列的一端插入，从队列的另一端删除，可以把队列理解为一根水管，水管有进水口和出水口。一般把允许数据插入的一端称为队尾（Tail或者Rear），一般把允许删除数据的一端称为队头队首（Head或者Front）。\n把允许数据插入的一端称为队尾（允许数据插入到队列的操作称为入队，英文enqueue） 把允许删除数据的一端称为队头（允许数据从队列删除的操作称为出队，英文dequeue） 队列也属于线性结构，所以根据数据元素之间的物理关系来划分的话同样可以以数组或者链表为基础来实现队列的操作。\n以数组为基础实现循环队列 如果以数组为基础，一般会把队列设置为循环队列，循环队列也被称为“环形缓冲区”，因为如果队列中的元素出队，则需要把该元素的后继元素整体向前移动，这是时间复杂度为O(n)的操作。\n如果数据出队之后不去移动后继元素又会导致数组的空间被浪费，为了解决该问题，可以把队列设置为循环队列，在移动数据的时候只需要移一次即可，所以时间复杂度就是O(1)。\n1. 定义数据类型与队列结构 1.1 数据类型定义 循环队列的元素类型可以根据需要进行更改。在此示例中，我们将队列的数据类型定义为 int，并且可以根据需求将其更改为其他类型，如 float 或 char。\n// 循环队列的数据类型 typedef int DataType_t; 1.2 队列结构体定义 我们需要定义一个结构体来管理循环队列的相关信息，包括队列的数据存储、队列的容量、队头和队尾指针。结构体 CirQueue_t 将包含以下成员：\naddr：指向存储数据的数组。 size：队列的最大容量。 rear：队尾指针，指向下一个入队位置。 front：队首指针，指向当前出队的位置。 // 构造循环队列的各项参数（首地址，容量大小，队尾下标，队首下标） typedef struct CircularQueue { DataType_t *addr; // 记录循环队列首元素地址 unsigned int size; // 记录循环队列容量大小 int rear; //  …","date":"2025-04-28 17:41:58","updated":"2025-04-28 17:41:58"},{"objectID":"1745660518","permalink":"/post/seqisstrvail/","title":"笔试题：C语言使用顺序栈判断字符串中的括号有效性","content":" 一、背景介绍 通过键盘输入一个包括 \u0026amp;lsquo;(\u0026amp;rsquo; 和 \u0026amp;lsquo;)\u0026amp;rsquo; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。\n我们可以利用 顺序栈（Sequence Stack）来解决这个问题，因为栈结构可以有效地跟踪括号的匹配关系。顺序栈是一个静态实现的栈数据结构，它通过数组实现栈的各项操作，具有较高的时间和空间效率。\n本文将介绍如何使用顺序栈来判断括号是否有效，以下是解决该问题的详细步骤。\n二、算法设计 解决括号匹配问题的基本思路如下：\n入栈操作： 当遇到左括号 ( 时，将其压入栈中。 出栈操作： 当遇到右括号 ) 时，从栈中弹出栈顶元素。 如果栈为空，表示没有对应的左括号，返回无效。 如果弹出的栈顶元素是左括号 (，继续判断下一个字符。 结束后检查栈是否为空： 如果栈不为空，说明有未匹配的左括号，返回无效。 如果栈为空，表示所有括号均有效，返回有效。 版本：\n/** * @file name : SeqenceIsStrVaild.c * @brief : 通过键盘输入一个包括 \u0026amp;#39;(\u0026amp;#39; 和 \u0026amp;#39;)\u0026amp;#39; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。 * @author : qrshxc@163.com * @date : 2025/04/26 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 三、顺序栈的实现 顺序栈是一种通过数组实现的栈数据结构，通常需要维护三个基本操作：入栈、出栈、检查栈是否为空。\n1. 顺序栈的定义 我们首先定义顺序栈的结构体 SeqStack_t，包括栈底指针、栈容量和栈顶指针。\nc复制编辑typedef char DataType_t; // 栈数据类型 // …","date":"2025-04-26 17:41:58","updated":"2025-04-26 17:41:58"},{"objectID":"1745574118","permalink":"/post/seqstack/","title":"笔试题：C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数","content":" 一、背景介绍 栈是一种特殊的线性表，特殊在栈的一端是封闭的，数据的插入与删除只能在栈的另一端进行，也就是栈遵循“后进先出”的原则。也被成为“LIFO”结构，意思是“last input first output”。\n栈（stack）,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈（PUSH）、出栈（POP）的说法。\n栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。\n闭合的一端被称为栈底（Stack Bottom），允许数据的插入与删除的一端被称为栈顶（Stack Top），不包含任何元素的栈被称为空栈。\n把数据插入到栈空间的动作被称为入栈或者压栈 从栈空间中删除数据的动作被称为出栈或者弹栈 由于栈也是一种线性结构，所以可以以数组或者链表作为基础，在此基础上实现栈的操作。\n以数组作为基础实现栈空间（顺序栈）\n数组在内存中占用一块连续的空间，也就是数组元素的内存地址是连续的。为了实现栈，一般是把数组头作为栈底，数组头部到数组尾部作为栈的增长方向，也就是用户只在数组尾部对数据进行插入和删除。\n以链表作为基础实现栈空间（链式栈）\n如果打算实现链式栈，一般是以链表作为基础，一般是把链表头部作为栈顶，方便数据的插入和删除（头插+头删），链式栈相当于是一个单向不循环的链表。\n本篇博客将展示如何使用顺序栈实现以下功能：\n顺序栈的实现：创建栈、判断栈满与栈空、栈的入栈与出栈操作等。 进制转换：通过栈来实现将十进制数转换为十六进制数。 二、顺序栈的实现 顺序栈使用数组来实现，它包含以下基本操作：\n入栈：将元素压入栈顶。 出栈：从栈顶弹出元素。 判断栈是否为空：栈空时返回true，否则返回false。 判断栈是否满：栈满时返回true，否则返回false。 首先，我们来看看顺序栈的结构和各个操作的实现。\n版本：\n/** * @file name : SequenceStack.c * @brief : C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数 * @author : qrshxc@163.com * @date : 2025/04/24 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 …","date":"2025-04-25 17:41:58","updated":"2025-04-25 17:41:58"},{"objectID":"1745401318","permalink":"/post/doublecirlinkedlist/","title":"C语言实现双向循环链表：创建、插入与删除操作","content":"在数据结构中，链表是基础而重要的一部分，而双向链表和循环链表则在一些特定场景下提供了更多灵活性和高效性。今天，我们将探讨如何使用 C 语言实现一个双向循环链表，并实现其基本操作：创建链表、插入节点、删除节点、遍历等。\n双向循环链表的定义 双向链表每个节点都包含三个部分：\n数据域：存储实际数据。 前驱指针：指向当前节点的前一个节点。 后继指针：指向当前节点的下一个节点。 循环特性则意味着链表的尾节点的后继指针指向头节点，头节点的前驱指针指向尾节点。这种结构使得从任意一个节点开始都可以进行完整的遍历。\n/** * @file name : DoubleCircularLinkedList.c * @brief : 实现双向循环链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/23 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要定义链表节点的数据结构。每个节点将包含数据域、前驱指针和后继指针。\n// 单向链表的数据类型 typedef int DataType_t; // 构造链表的节点 typedef struct DoubleCirLinkedList { DataType_t data; // 节点的数据域 struct DoubleCirLinkedList *prev; // 直接前驱的指针域 struct DoubleCirLinkedList *next; // 直接后继的指针域 } DoubleCirLinkedList_t; 我们首先定义一个函数来创建一个空链表并初始化头结点。头结点的 next 和 prev 都指向自己，体现了链表的循环特性。\n/** * @name DoubleCirLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/23 * @version 1.0 * @note 返回初始化的头结点 */ DoubleCirLinkedList_t * …","date":"2025-04-23 17:41:58","updated":"2025-04-23 17:41:58"},{"objectID":"1745228518","permalink":"/post/doublelinkedlist/","title":"C语言实现双向链表：创建、插入与删除操作","content":"在这篇博客中，我们将深入探讨如何用 C 语言实现一个双向链表。我们将逐步实现双向链表的基本操作，包括节点的增、删、查、遍历等，并解释相关的概念与代码实现。与普通链表相比，双向链表的每个节点包含两个指针域：一个指向前一个节点，另一个指向下一个节点，从而使得操作变得更加灵活。\n什么是双向链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而双向链表的特点是： 双向链表中，每个节点不仅包含指向下一个节点的指针，还包含指向前一个节点的指针。这使得双向链表可以在两个方向上进行遍历。 双向链表非常适用于需要在两个方向遍历的数据结构，例如浏览器的前进/后退按钮、双向队列等。 设计双向链表 为了实现双向链表，我们首先需要定义一个链表节点的结构体（DoubleLinkedList_t）。该结构体包含三个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 prev：指向前一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的双向链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : DoubleLinkedList.c * @brief : 实现双向链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/21 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要实现一个函数来创建一个空的双向链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向 NULL，表示链表为空。\n/** * @name DoubleLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/19 * @version 1.0 * @note 返回初始化的头结点 */ DoubleLinkedList_t * …","date":"2025-04-21 17:41:58","updated":"2025-04-21 17:41:58"},{"objectID":"1745055718","permalink":"/post/circularlinkedlist/","title":"C语言实现单向循环链表：创建、插入与删除操作","content":"在本篇博客中，我们将深入探讨如何用 C 语言实现一个单向循环链表。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 next 指针指向的是头节点，从而形成了一个闭环。\n什么是循环链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而循环链表的特点是：\n单向循环链表中，最后一个节点的 next 指针不指向 NULL，而是指向头节点。也就是说，遍历链表时，最后会回到头节点，形成一个闭环。 循环链表非常适用于需要重复遍历的数据结构，比如缓冲区、任务调度等。 设计单向循环链表 为了实现单向循环链表，我们首先需要定义一个链表节点的结构体（CircLList_t）。该结构体包含两个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的单向循环链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : CircularLinkedList.c * @brief : 实现单向循环链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/18 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建单向循环链表 首先，我们需要实现一个函数来创建一个空的单向循环链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向自己，表示链表为空。\n/** * @name CircularLinkedList_Create * @brief 创建一个空单项循环链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/18 * @version 1.0 * @note */ CircularLinkedList * …","date":"2025-04-19 17:41:58","updated":"2025-04-19 17:41:58"},{"objectID":"1744710118","permalink":"/post/linkedlist/","title":"用 C 语言实现单向链表","content":"在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。\n版本：\n链表基础知识 链表是一种数据结构，它由一系列节点（Node）构成，每个节点包含两个部分：\n数据域（Data）：存储实际的数据。 指针域（Next）：指向下一个节点的指针。 单向链表 单向链表是最简单的链表形式，每个节点只有一个指针域，指向下一个节点。最后一个节点的指针域为空（NULL），表示链表的结尾。\n实现单向链表 我们将实现以下几个功能：\n链表创建：创建一个空的链表。 节点插入：支持头部插入、尾部插入和指定位置插入。 节点删除：删除链表中的指定节点。 查找节点：查找链表中是否包含指定数据的节点。 更新节点：修改链表中指定节点的数据。 遍历链表：遍历并打印链表中的所有节点。 /** * @file name : LinkedList.c * @brief : 实现链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/09 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 链表创建 链表的创建首先需要创建一个头节点。头节点不存储实际数据，但它是链表的起点，所有的操作都需要从头节点开始。我们使用 calloc 动态分配内存来创建头节点。\n/** * @name LinkedList_Create * @brief 创建一个空链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/09 * @version 1.0 * @note */ LinkedList_t *LinkedList_Create(void) { //给头结点申请一片内存 LinkedList_t * head = (LinkedList_t *)calloc(1,sizeof(LinkedList_t)); //错误处理 if (head == NULL) { …","date":"2025-04-15 17:41:58","updated":"2025-04-15 17:41:58"},{"objectID":"1744191718","permalink":"/post/sequencelist/","title":"数据结构-顺序表的增、删、改、查（C语言版）","content":"顺序表指的是使用一组内存地址连续的内存单元来依次存储线性表中的数据元素，使用这种存储结构的线性表就被称为顺序表。\n简单理解：数据存储在一块连续的内存中，在C 语言中可以具名的数组，也可以使用匿名的数组（堆内存）。\n顺序表的特点：数据元素之间的逻辑关系是相邻的，并且内存地址也是相邻的，所以只要知道存储线性表的第一个数据元素的内存地址，就可以对线性表中的任意一个元素进行随机访问。通常用户使用动态分配的数组来实现顺序表,也就是使用堆内存实现。\n版本：\n/** * @file name : SequenceList.c * @brief : 实现顺序表元素的增删改查 * @author : qrshxc@163.com * @date : 2025/04/07 * @version : 1.0 * @note : 模块化实现 * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 顺序表的结构定义 首先，我们需要定义一个结构体来表示顺序表，包括数据类型和数据表各项参数等信息：\ntypedef int DataType_t; //构造顺序表SquenceList各项参数（顺序表的首地址，容量大小，有效元素最后的下标） typedef struct SequenceList { DataType_t *addr;//记录顺序表首元素地址 unsigned int size;//记录顺序表容量大小 int last;//记录顺序表有效元素最后下标 }SeqList_t; 创建一个空顺序表 创建顺序表并对顺序表进行初始化\n/** * @name SeqList_create * @brief 创建顺序表并对顺序表进行初始化 * @param size 顺序表的大小 * @return * @retval manager 顺序表的管理结构体 * @date 2025/04/07 * @version 1.0 * @note Manager-\u0026amp;gt;Addr ---\u0026amp;gt; [Size*sizeof(DataType_t)] */ SeqList_t *SeqList_create(unsigned size) { // 1.利用calloc给管理结构体manager申请一块堆内存 SeqList_t …","date":"2025-04-09 17:41:58","updated":"2025-04-09 17:41:58"}]