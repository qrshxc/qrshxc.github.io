[{"objectID":"1745055718","permalink":"/post/circularlinkedlist/","title":"C语言实现单向循环链表：创建、插入与删除操作","content":"在本篇博客中，我们将深入探讨如何用 C 语言实现一个单向循环链表。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 next 指针指向的是头节点，从而形成了一个闭环。\n什么是循环链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而循环链表的特点是：\n单向循环链表中，最后一个节点的 next 指针不指向 NULL，而是指向头节点。也就是说，遍历链表时，最后会回到头节点，形成一个闭环。 循环链表非常适用于需要重复遍历的数据结构，比如缓冲区、任务调度等。 设计单向循环链表 为了实现单向循环链表，我们首先需要定义一个链表节点的结构体（CircLList_t）。该结构体包含两个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的单向循环链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : CircularLinkedList.c * @brief : 实现单向循环链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/18 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建单向循环链表 首先，我们需要实现一个函数来创建一个空的单向循环链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向自己，表示链表为空。\n/** * @name CircularLinkedList_Create * @brief 创建一个空单项循环链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/18 * @version 1.0 * @note */ CircularLinkedList * …","date":"2025-04-19 17:41:58","updated":"2025-04-19 17:41:58"},{"objectID":"1744710118","permalink":"/post/linkedlist/","title":"用 C 语言实现单向链表","content":"在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。\n版本：\n链表基础知识 链表是一种数据结构，它由一系列节点（Node）构成，每个节点包含两个部分：\n数据域（Data）：存储实际的数据。 指针域（Next）：指向下一个节点的指针。 单向链表 单向链表是最简单的链表形式，每个节点只有一个指针域，指向下一个节点。最后一个节点的指针域为空（NULL），表示链表的结尾。\n实现单向链表 我们将实现以下几个功能：\n链表创建：创建一个空的链表。 节点插入：支持头部插入、尾部插入和指定位置插入。 节点删除：删除链表中的指定节点。 查找节点：查找链表中是否包含指定数据的节点。 更新节点：修改链表中指定节点的数据。 遍历链表：遍历并打印链表中的所有节点。 /** * @file name : LinkedList.c * @brief : 实现链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/09 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 链表创建 链表的创建首先需要创建一个头节点。头节点不存储实际数据，但它是链表的起点，所有的操作都需要从头节点开始。我们使用 calloc 动态分配内存来创建头节点。\n/** * @name LinkedList_Create * @brief 创建一个空链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/09 * @version 1.0 * @note */ LinkedList_t *LinkedList_Create(void) { //给头结点申请一片内存 LinkedList_t * head = (LinkedList_t *)calloc(1,sizeof(LinkedList_t)); //错误处理 if (head == NULL) { …","date":"2025-04-15 17:41:58","updated":"2025-04-15 17:41:58"},{"objectID":"1744191718","permalink":"/post/sequencelist/","title":"数据结构-顺序表的增、删、改、查（C语言版）","content":"顺序表是数据结构中最基本的一种线性表，它以一段连续的存储空间来存储数据元素，元素之间的顺序由它们在内存中的位置来决定。在C语言中，我们通常使用数组来实现顺序表。\n版本：\n/** * @file name : SequenceList.c * @brief : 实现顺序表元素的增删改查 * @author : qrshxc@163.com * @date : 2025/04/07 * @version : 1.0 * @note : 模块化实现 * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 顺序表的结构定义 首先，我们需要定义一个结构体来表示顺序表，包括数据类型和数据表各项参数等信息：\ntypedef int DataType_t; //构造顺序表SquenceList各项参数（顺序表的首地址，容量大小，有效元素最后的下标） typedef struct SequenceList { DataType_t *addr;//记录顺序表首元素地址 unsigned int size;//记录顺序表容量大小 int last;//记录顺序表有效元素最后下标 }SeqList_t; 创建一个空顺序表 创建顺序表并对顺序表进行初始化\n/** * @name SeqList_create * @brief 创建顺序表并对顺序表进行初始化 * @param size 顺序表的大小 * @return * @retval manager 顺序表的管理结构体 * @date 2025/04/07 * @version 1.0 * @note Manager-\u0026amp;gt;Addr ---\u0026amp;gt; [Size*sizeof(DataType_t)] */ SeqList_t *SeqList_create(unsigned size) { // 1.利用calloc给管理结构体manager申请一块堆内存 SeqList_t *manager = (SeqList_t *)calloc(1,sizeof(SeqList_t)); //错误处理 if(manager == NULL){ perror(\u0026amp;#34;calloc memory for manager is failed!\u0026amp;#34;); …","date":"2025-04-09 17:41:58","updated":"2025-04-09 17:41:58"}]