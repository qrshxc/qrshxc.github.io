[{"objectID":"1754646118","permalink":"/post/freertos/","title":"嵌入式实时系统的核心原理与 FreeRTOS 移植指南","content":" 一、RTOS的基本概念 实时操作系统（Real Time Operating System）的简称就叫做RTOS，是指具有实时性、能支持实时控制系统工作的操作系统，RTOS的首要任务就是调度所有可以利用的资源来完成实时控制任务的工作，其次才是提高工作效率。\nRTOS就是一段嵌入在程序中的代码，在系统上电复位后首先被执行，可以理解为用户的主程序，只不过用户把产品的其他功能（子程序）都建立在RTOS之上，在RTOS中可以调用API函数为每个子程序都创建一个任务（也可以叫做线程），用户只需要调用RTOS内核中的相关的API函数接口就可以控制子程序，而且可以为每个任务设置不同的优先级，通过RTOS的调度器进行调度，这样就可以合理的使用CPU。\n这里就涉及到产品的设计思路（裸机开发 or RTOS）以及程序的运行方式，可以分为三种：\n1.轮询式 轮询系统指的是程序运行时，先初始化各种硬件，初始化硬件之后程序进入一个死循环中，按照事件的顺序进行执行，该系统的结构非常简单，只适用于按照顺序执行事件并且没有外部事件来打断的情况，轮询系统就非常可靠，但是一旦有外部事件或者外部需要检测的信号来打断，则会造成外部事件的缺失。\nint main() { //硬件的初始化 while(1) { //事件1 LED //事件2 BEEP //....... KEY } } 前后台系统就是在轮询系统的基础上增加了中断，进行外部事件检测的时候就在中断中实现，所以中断也被称为前台，而其他事件还是在主程序的死循环中按照顺序执行，一旦中断发生，则会暂停执行后台的while(1),然后去执行前台的中断服务函数，如果事件简短，直接在中断中实现，如果事件复杂，则返回主程序的死循环实现，该方案可以提高程序的实时响应能力。\nint main() { //硬件的初始化 //注册中断，设置中断的触发条件 while(1) { //事件1 //事件2 ..... } } //中断服务函数 void XXX_IRQ (void) { //执行中断的事件 //执行完成返回main函数 } 3.多任务 多任务系统指的是在前后台系统的基础上执行外部事件，只不过外部事件是放在任务中执行，不在中断服务函数中执行，一旦某个外部事件满足触发条件，就在中断服务函数中设置事件标志，然后在跳转到任务中执行事件，任务分优先级的，优先级高的任 …","date":"2025-08-08 17:41:58","updated":"2025-08-08 17:41:58"},{"objectID":"1754559718","permalink":"/post/acm/","title":"RFID 多标签防碰撞机制深度解析：读写器如何从多张卡片中准确选中一张？","content":"在各种实际应用场景中，RFID 技术往往需要面对多个标签同时进入射频场的复杂情况。无论是地铁闸机、高速仓储线上的商品标签，还是智能门禁系统，如果读写器无法从同时存在的多张标签中准确识别出某一张要进行读写的标签，那么整套系统就会变得不稳定甚至失效。因此，如何在多标签并发的情况下保持通信的有序和可靠，就成为 RFID 技术中不可绕开的核心问题，这也催生了所谓的“防碰撞机制”。\n所谓“碰撞”，是指多个 RFID 标签同时响应读写器的询问命令，并同时把数据调制回射频场，由于这些信号叠加在一起，读写器无法正确分辨，从而导致识别失败。与接触式 IC 卡不同，RFID 标签并不会插在卡座里，而是自由放置在读写器周围的电磁场内。因此，读写器在发起一个询问信号时，射频场中的所有标签都会“听到”，并且会同时作出响应。正因为这种“共享媒介”的特性，RFID 系统必须具备一个机制——让标签在必要的时候“安静”，在需要的时候“发言”，并能够按读写器的节奏进行通信。\n在众多 RFID 标准中，最典型的一类防碰撞机制是基于标签唯一序列号的“位碰撞解析”。这种方法被 ISO14443A 和 Mifare 系列卡片采用，也是我们日常使用的公交卡、门禁卡等最常见的方式。每张 RFID 卡都有一个全球唯一的 UID，当读写器要求所有卡片返回 UID 时，它们会从第一位开始同时回送自己的 UID。如果某几位恰好一致，读写器就能正常接收；但当某一位上出现“有的标签回送 0，有的回送 1”的情况时，就会出现调制信号的重叠，读写器就能立即判断这是一次碰撞。为了避免这种碰撞持续发生，读写器会根据协议选择某一类标签继续说话，比如指定“刚才冲突位为 1 的继续发言”，而让其他标签暂时保持静默。这样做的好处在于，每一次冲突都能把标签分成两组，然后逐步排除，最终一定能筛选出唯一的一张标签。由于 UID 的长度固定，这种方法最多只需要迭代几十轮，就能从几百万张标签中准确找到唯一一张。\n这种机制之所以稳健，除了 UID 的唯一性，还与 ISO14443A 的调制编码方式有关。标签向读写器回送数据时使用了带副载波的曼彻斯特编码，0 和 1 分别调制在码元的后半部分和前半部分。如果同一个码元中前后半部分都出现调制，读写器便能立刻识别为冲突，这保证了防碰撞过程在物理层面能够正确分组。\n另一类防碰撞思想更接近期望“排队叫号”的方式， …","date":"2025-08-07 17:41:58","updated":"2025-08-07 17:41:58"},{"objectID":"1754386918","permalink":"/post/iic/","title":"IIC总线通信与AT24C02存储芯片及OLED屏应用详解","content":" 一、内部集成电路概述 1. 基本概念 内部集成电路（Inter Integrated Circuit）的简称叫做IIC 或者I2C，是一种简单的、半双工同步通信的串行通信接口，IIC 总线是上世纪80 年代（1982 年）由飞利浦公司设计出来，当时的目的是为了给MCU 和外围芯片提供更简单的交互方式。\n2.引脚说明 IIC 总线只需要两根引脚就可以实现通信，一根是数据线（SDA Serial Data），另一根是时钟线（SCL Serial Clock），所有通过IIC 接口通信的外围器件都挂载在IIC 总线上，通过这种机制就可以实现多机通信。\n可以看到，外围器件的时钟线和数据线都是挂载在IIC 总线（由主控芯片提供），并且在空闲状态下所有器件的时钟线（SCL）和数据线（SDA）都被总线的上拉电阻拉高，这样就可以把SDA 引脚和SCL 引脚设置为开漏模式即可，好处是防止短路。\n思考：如果IIC 总线上挂载了多个外围器件，如何与某一个器件进行单独通信？ 答：器件地址\n3.通信速率 可以看到IIC 总线支持不同的通信速率，但是一般常用的标准速率100KHZ，但是有的外围器件可以支持高达400KHZ 的通信速率，而由于IIC 总线是半双工通信，所以同一时刻只能接收或者发送，也就是说IIC 总线一般是为了控制，不适合作为大量数据传输的接口。\n4.通信过程 (1) 空闲状态 (2) 开始信号 (3) 数据传输 (4) 应答信号 (5) 停止信号 5.器件地址 6.程序设计 myiic.h /** ****************************************************************************** * @file myiic.h * @author * @version V1.0 * @date 2025.08.05 * @brief IIC驱动头文件 SCL--PB8 SDA--PB9 ****************************************************************************** **/ #ifndef __MYIIC_H #define __MYIIC_H #include \u0026amp;#34;stm32f4xx.h\u0026amp;#34; #include …","date":"2025-08-05 17:41:58","updated":"2025-08-05 17:41:58"},{"objectID":"1754300518","permalink":"/post/rfid/","title":"STM32与RFID模块(MFRC522)完全应用指南","content":" 一、RFID 模块的原理与应用 1. 基本概念 RFID 技术也简称为射频识别技术，是20 世纪40 年代开始出现的一种自动识别技术。RFID通过无线射频信号获取物体的相关数据，并对物体加以识别，RFID 技术不需要和被识别物体进行直接接触就可以完成物体信息的处理，也不需要人工干预，可以实现无接触式信息传递，能应用在各种较为恶劣的环境中。所以说RFID 技术是一种快速、高效的采集和处理物体信息的自动识别技术。\n随着计算机和互联网的发展，物联网的概念也被提出，而物联网想要实现的是“万物互联”物联网的核心思想是为全球每一个物品提供唯一的电子标签，而RFID 可以实现无接触式的信息传递达到识别物体的目的。所以RFID 技术也是实现物联网的关键技术之一。RFID 技术的实现离不开软件与硬件的支持，硬件一般包含应答器、天线和阅读器。软件一般包含数据管理系统。\n电子标签也叫作应答器，一般是由集成电路芯片和内置天线组成的，芯片用来存储物体相关数据，内置天线用来收发无线电波。电子标签一般附着在物体上用来标识物体，每个标签具有唯一的电子编码。电子标签的种类有很多，比如低频标签、高频标签等，并且电子标签的样式也有多种，比如条型、卡片型、环型、纽扣型等。\n而对于识读器而言，也称为阅读器或者读写器，是对电子标签信息读取和写入的设备。阅读器可以和计算机进行联网，作用一般是作为数据交换的媒介，阅读器一般由射频模块、控制模块和天线组成。也可以把阅读器理解为一个特殊的无线通信模块，它可以和电子标签通过天线进行无线通信。阅读器可以工作在一个或多个工作频段，也可以读写一种或多种电子标签，阅读器的种类有很多，比如手持式的、固定式的，使用起来非常方便。\n2.接口说明 本次使用RFID 模块内部采用的IC 是MFRC522 型号，需要阅读IC 的数据手册，了解该IC 的接口，可以知道RFID 模块支持SPI 接口。\n3.工作模式 4.通信机制 5.访问流程 6.程序设计 main.c /** ****************************************************************************** * @file main.c * @author qrshxc@163.com * @version V1.0 * @date 2025.08.04 * …","date":"2025-08-04 17:41:58","updated":"2025-08-04 17:41:58"},{"objectID":"1754214118","permalink":"/post/spiflash/","title":"STM32 SPI接口与Flash存储芯片完全指南","content":" 一、串行外设接口(SPI)深度解析 单总线协议指的是只采用一根信道来进行数据传输，通信指的是双方（MCU 与传感器）通过一根信道进行数据交互，所以按照数据的传输方向，只能采用半双工通信方式，比较典型的传感器就是温度传感器（DS18B20、DHT11\u0026amp;hellip;\u0026amp;hellip;）\n1. SPI基本概念 串行外设接口（Serial Peripheral Interface）的简称也叫做SPI，是一种高速的、全双工同步通信的一种接口，串行外设接口一般是需要4 根线来进行通信（NSS、MISO、MOSI、SCK），但是如果打算实现单向通信（最少3 根线），就可以利用这种机制实现一对多或者一对一的通信。\n2.引脚定义 SPI 总线采用的环形结构，利用的是主从模式（主机\u0026amp;mdash;-\u0026amp;gt;从机）进行数据的传输，由于是同步通信，所以在主机发送数据的同时也会收到从机发送的数据。\n3.工作模式 注意：采用SPI 接口进行通信，通信双方提前约定好使用哪个工作模式，此时主机可以有4种工作模式可以选择，此时选择哪种模式需要由从器件决定。主机需要配合从机！\n绝大多数的采用SPI 接口通信的传感器，一般都是支持模式0 或者模式3！！！！\n4.数据格式 主机与从机在通信的过程中传输的数据时以bit 为单位（串行传输），所以数据格式就十分重要，主机的数据格式必须要根据从机的数据格式进行设置（MSB 或者LSB），大多数使用SPI 接口通信的传感器一般都是使用MSB 高位先出。\n二、Flash 闪存芯片的使用 1.基本概念 由于STM32F407ZET6 这颗MCU 内部只有512KB 的Flash 闪存容量，这512KB 还需要用于固化应用程序，所以剩余的空间可能不足以让用户使用了，所以需要额外的拓展存储IC，必须具备掉电不丢失，所以GEC-M4 开发板中集成了一颗串行Flash 芯片，型号是W25Q128，容量是128Mbit，该存储IC 采用SPI 接口进行通信。\n2.内存分布 3.引脚说明 4.工作模式 5.指令分析 (1) 写使能指令 (2) 读状态寄存器 (3) 写失能指令 (4) 擦除扇区指令 (5) 读取厂商和设备ID 6.程序设计 /** …","date":"2025-08-03 17:41:58","updated":"2025-08-03 17:41:58"},{"objectID":"1754041318","permalink":"/post/dht11/","title":"单总线协议的原理和DHT11的应用","content":" 一、单总线协议的原理和应用 单总线协议指的是只采用一根信道来进行数据传输，通信指的是双方（MCU 与传感器）通过一根信道进行数据交互，所以按照数据的传输方向，只能采用半双工通信方式，比较典型的传感器就是温度传感器（DS18B20、DHT11\u0026amp;hellip;\u0026amp;hellip;）\n1.基本特征 2.测量精度 3.硬件接线 4.控制原理 3.程序设计 /** ****************************************************************************** * @file DHT11.c * @author qrshxc@163.com * @version V1.0 * @date 2025.08.01 * @brief 利用DHT11测试温湿度 PE0 ****************************************************************************** **/ #include \u0026amp;#34;stm32f4xx.h\u0026amp;#34; #include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;stdbool.h\u0026amp;gt; /** * @name delay_us * @brief 微秒级延时函数 * @param nus: 延时的微秒数 * @return 无 * @version 1.0 * @note 使用SysTick定时器实现精确微秒延时 */ void delay_us(u32 nus) { SysTick-\u0026amp;gt;CTRL = 0; // 关闭系统嘀嗒定时器 SysTick-\u0026amp;gt;LOAD = nus * 21 -1; // 计数次数，递减计数，0结束 SysTick-\u0026amp;gt;VAL = 0; // 清除当前数值寄存器 SysTick-\u0026amp;gt;CTRL = 1; // 打开系统嘀嗒定时器，使用参考时钟 while ((SysTick-\u0026amp;gt;CTRL \u0026amp;amp; 0x00010000)==0); // 等待计时完成 SysTick-\u0026amp;gt;CTRL = 0; // 关闭系统嘀嗒定时器 } /** * @name delay_ms * @brief 毫秒级延时函数 * @param nus: 延时的毫秒数 * @return 无 * …","date":"2025-08-01 17:41:58","updated":"2025-08-01 17:41:58"},{"objectID":"1753868518","permalink":"/post/iwdgrtc/","title":"STM32看门狗与RTC实时时钟完全指南","content":" 一、看门狗外设的原理与应用 随着单片机的发展，单片机在家用电器、工业自动化、生产过程控制、智能仪器仪表等领域的应用越来越广泛。然而处于同一电力系统中的各种电气设备通过电或磁的联系彼此紧密相连，相互影响，由于运行方式的改变、故障、开关操作等引起的电磁振荡会波及很多电气设备。这对我们单片机系统的可靠性与安全性构成了极大的威胁。单片机测控系统必须长期稳定、可靠运行，否则将导致控制误差加大，严重时会使系统失灵，甚至造成巨大损失。因此单片机的抗干扰能力已经成为不容忽视的问题。\n由于单片机在运行的过程经常会受到外部电磁场的干扰，就可能会出现程序“跑飞”，比如出现数据的缺失、导致寄存器中的数据发生变化、程序指针PC 指向非法地址\u0026amp;hellip;\u0026amp;hellip;..，为了提高程序的可靠性，就提供了看门狗外设，在程序出现由软件或者硬件导致的未知问题，利用 看门狗外设对芯片进行复位，相当于重新运行程序。\n如果程序运行没有任何问题，则可以”按时喂狗”，就不会让芯片复位，一旦程序出现问题导致无法喂狗，则看门狗会自动复位程序。\n使用看门狗的目的：为了提供程序的可靠性，防止由软件或者硬件造成的问题的出现。如果想要了解看门狗的资源和特点，可以参考STM32F4 中文参考手册。\n1.分类说明 STM32F4 系列的芯片提供的两个看门狗，一个叫做独立看门狗，一个叫做窗口看门狗。两个看门狗的使用流程差不多，但是相比于独立看门狗，窗口看门狗的要求更多。\n2.内部结构 3.程序设计 如果出现芯片复位的情况，如何判断是用户手动完成复位还是由IWDG 看门狗复位??\n/** ****************************************************************************** * @file IWDG.c * @author qrshxc@163.com * @version V1.0 * @date 2025.7.30 * @brief 独立看门狗(IWDG)应用示例 ****************************************************************************** **/ #include \u0026amp;#34;stm32f4xx.h\u0026amp;#34; /** * @name delay_ms * @brief …","date":"2025-07-30 17:41:58","updated":"2025-07-30 17:41:58"},{"objectID":"1753782118","permalink":"/post/light/","title":"STM32模数转换器(ADC)原理与应用完全指南 -——光敏电阻","content":" 一、模数转换的原理与应用 一般在电子线路中，信号分为两种：模拟信号 + 数字信号，大多数传感器采集的都是模拟信号，比如温度、湿度、压力\u0026amp;hellip;\u0026amp;hellip;. ，采集的模拟信号再转交给计算机进行处理，计算机处理的是数字信号，其中涉及到模拟量和数字量的转换，会使用模数转换器，也被称为ADC。\n1. 基本概念 2.转换原理 (1) 取样 (2) 量化 (3) 编码 同上图\n3.转换精度 4.内部框图 5.程序设计 由于ADC 转换器需要结合传感器使用，本次的案例就以开发板的光敏电阻为例实现\n/** ****************************************************************************** * @file light.c * @author qrshxc@163.com * @version V1.0 * @date 2025.7.29 * @brief 利用光敏电阻读取数据 PF7 ADC3_IN5 ****************************************************************************** **/ #include \u0026amp;#34;stm32f4xx.h\u0026amp;#34; #include \u0026amp;lt;stdio.h\u0026amp;gt; /** * @name delay_ms * @brief 毫秒级延时函数 * @param nus: 延时的毫秒数 * @return 无 * @version 1.0 * @note 使用SysTick定时器实现精确毫秒延时 */ void delay_ms(u32 nus) { SysTick-\u0026amp;gt;CTRL = 0; // 关闭系统嘀嗒定时器 SysTick-\u0026amp;gt;LOAD = nus * 21 * 1000 -1; // 计数次数，递减计数，0结束 SysTick-\u0026amp;gt;VAL = 0; // 清除当前数值寄存器 SysTick-\u0026amp;gt;CTRL = 1; // 打开系统嘀嗒定时器，使用参考时钟 while ((SysTick-\u0026amp;gt;CTRL \u0026amp;amp; 0x00010000)==0); // 等待计时完成 SysTick-\u0026amp;gt;CTRL = 0; // 关闭系统嘀嗒定时器 } /** * @name …","date":"2025-07-29 17:41:58","updated":"2025-07-29 17:41:58"},{"objectID":"1753695718","permalink":"/post/ble/","title":"STM32蓝牙模块的原理与应用","content":"一般MCU 和计算机通信是采用有线方式实现，这种方案的缺点是实用性较差，无法实现良好的人机交互，所以正常应该是采用无线通信的方式实现对MCU 的控制，一般主流的无线通信方式有BLE、WIFI、Zigbee、LoRa，其中Zigbee、LoRa 可以实现组网通信，其实BLE 蓝牙也可以实现组网通信，当然蓝牙除了组网之外，最常用就是方案就是利用手机远程控制硬件。\n不同厂商的蓝牙模块的型号可能不同，但是通信方式是一样，都是采用串口通信，但是需要再使用蓝牙模块之前先进行参数设置，目的是和手机可以进行配对，想要修改蓝牙的参数（名称、密码、波特率\u0026amp;hellip;\u0026amp;hellip;）都需要使用厂家提供的指令集实现，一般再哪个淘宝店买的蓝牙模块就在哪个淘宝店下载蓝牙模块的资料。\n1. 蓝牙概述 2.硬件接线 3.程序设计 /** ****************************************************************************** * @file ble.c * @author qrshxc@163.com * @version V1.0 * @date 2025.7.28 * @brief 利用USART2连接蓝牙模块，实现无线控制功能 ****************************************************************************** **/ #include \u0026amp;#34;stm32f4xx.h\u0026amp;#34; #include \u0026amp;lt;string.h\u0026amp;gt; #define BUFFSIZE 128 // 接收缓冲区大小 uint8_t data[BUFFSIZE] = {0}; // 数据接收缓冲区 uint32_t count = 0; // 接收数据计数 /** * @name delay_ms * @brief 毫秒级延时函数 * @param nus: 延时的毫秒数 * @return 无 * @version 1.0 * @note 使用SysTick定时器实现精确毫秒延时 */ void delay_ms(u32 nus) { SysTick-\u0026amp;gt;CTRL = 0; // 关闭系统嘀嗒定时器 SysTick-\u0026amp;gt;LOAD = nus * 21 * …","date":"2025-07-28 17:41:58","updated":"2025-07-28 17:41:58"},{"objectID":"1753609318","permalink":"/post/usart/","title":"STM32串口通信","content":" 一、串口通信的原理与应用 1. 通信的方式 处理器与外部设备之间或者处理器与处理器之间通信的方式分两种：串行通信和并行通信。\n串行通信 传输原理：数据按位依次顺序传输（每一位占据固定的时间长度 MSB or LSB） 优点：占用引脚资源少、成本低、传输距离远 缺点：速度慢 应用场合：常用于工控、测量设备，以及部分通信设备 如 USB、COM 口\n并行通信 传输原理：数据按位同时传输（按照字节或者字节的倍数去传输） 优点：速度快 缺点：占用引脚多，成本高、传输距离近、抗干扰能力弱（串扰） 应用场合：一般适用数据量大、传输距离较近的场合 如计算机总线\n2. 串行通信分类 如果按照数据的传送方向，可以分为3 种\n**单 工 ：**数据只能从一方传向另一方，而不能往反方向传输。这是根据应用的特点，对通信双方的软、硬件进行了简化。单向传输设备，如并行接口打印机就是通过单工的方式进行数据传输的。 半双工 ：允许数据往两方传向传输，但只能交替进行，而不能同时进行的传输方式。常见应用如对讲机。 **全双工 ：****数据支持同时在两个方向上传输，就相当于两个单工通信的结合 如移动电话\n如果按照数据的同步方式，可以分为2 种\n**同步通信：**指的是带时钟同步信号，如IIC 接口和SPI 接口都属于同步通信，同步通信要求通信双方的时钟必须一致（发送数据的同时进行接收数据），同步通信是一种连续串行传输数据的通信方式，一次只传输一帧数据，相对于异步通信而言传输速率更高，但是缺点是通信双方必须使用同一个时钟。\n**异步通信：**指的是不带时钟同步信号，如UART 接口就属于异步通信，要求通信双方必须具有接收器和发送器，但是接收器和发送器可以使用各自的时钟，异步通信是以字符为单位去传输，由于异步通信工作是非同步的，所以接收器必须时刻做好接收数据的准备，所以每个 字符都会使用起始位和停止位代表字符的开始和结束，相比于同步通信而言设备成本低，但是缺点是信道利用率低。\n注意：使用异步通信，通信双方要约定好的字符格式和通信速率，否则会导致数据丢失等\n3.串行接口意义 串行通信就是把数据按位进行顺序传输，在计算机传输的过程中是使用并行通信的，就涉及到串转并和并转串。可以利用软件实现，也可以用硬件实现。如果使用软件实现，会增大CPU 的负担，通常使用硬件（串口）实现。\n串口是计算机进行串行通信的物理接 …","date":"2025-07-27 17:41:58","updated":"2025-07-27 17:41:58"},{"objectID":"1753436518","permalink":"/post/pwm/","title":"STM32定时器：从基础定时到PWM高级应用","content":" 一、STM32 基本定时器的原理与应用 1. 基本概念 定时器的作用一般是为了使用定时功能和中断功能（洗衣机、微波炉\u0026amp;hellip;..），当然在STM32中也可以利用定时器产生周期性的脉冲信号来控制不同的外设（灯的亮度、电机的转速、舵机的角度\u0026amp;hellip;\u0026amp;hellip;），所以掌握STM32 中的定时器对于项目开发是很有必要的。\n2. 外设种类 对于STM32F407 微处理器而言，内部一共集成了14 个定时器，其中有2 个基本定时器（TIM6和TIM7）、10 个通用定时器（TIM2TIM5、TIM9TIM14）、2 个高级定时器（TIM1 和TIM8）。\n其中通用定时器TIM2 和TIM5 为32 位定时器，其他为16 位定时器，当然，定时器位数越大，定时时间越久。\n3.基本特点 4.原理分析 5.程序设计 /** * @name Time_Config * @brief 配置TIM7定时器 * @param 无 * @return 无 * @date 2025.7.25 * @version 1.0 * @note 配置TIM7定时器产生5秒周期中断，控制蜂鸣器 */ void Time6_Config() { /* 定义TIM6结构体变量 */ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; /* 定义NVIC结构体变量 */ NVIC_InitTypeDef NVIC_InitStructure; /* 打开TIM7时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE); /* 对Time6结构体变量赋值+初始化 */ TIM_TimeBaseStructure.TIM_Prescaler = 8400-1;\t// 84000000/8400=10000Hz，每100us计数一次 TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; // 向上计数模式 TIM_TimeBaseStructure.TIM_Period = 50000-1; // 50000*100us=5秒中断一次 TIM_TimeBaseInit(TIM7, …","date":"2025-07-25 17:41:58","updated":"2025-07-25 17:41:58"},{"objectID":"1753263718","permalink":"/post/timer/","title":"STM32系统时钟与SysTick定时器","content":" 一、系统嘀嗒定时器(SysTick)全面解析 1. SysTick定时器基本概念 定时器是STM32 中常用的外设，一般定时器的基本功能就是定时，而在Cortex M3/M4 内核中也包含一个简单的定时器，就是系统嘀嗒定时器(Systick)，它是属于M4 内核的一个外设，内嵌在NVIC 中，所有基于Cortex-M3/M4 内核的MCU 中都包含这个Systick 定时器，所以在不同的硬件中移植起来非常方便。 由于Systick 定时器属于CM4内核，所以大家在STM32F4 中文参考手册中是找不到关于Systick时器的相关信息，所以可以在CM3 权威指南或者Cortex M3/M4 权威指南中找到。\n2. 基本应用 (1) 裸机开发：编写专门的延时函数，实现微秒、毫秒级别的延时，如作为闹钟或者延时。 (2) 操作系统：可以为RTOS 实时操作系统的任务调度提供时钟节拍，RTOS 的架构是并行的。\n3.时钟分析 如果打算利用Systick 定时器进行定时，则必须清楚Systick 定时器的时钟频率，而定时器是挂载在总线下，而不同的总线的频率是不同的，而总线的频率是由时钟提供，而时钟的提供者又各不相同，所以必须要提前了解时钟源的区别。\n一般情况下一款MCU 有多种时钟源(用于提供时钟信号)，时钟源一般可以分为两类：内部时钟源、外部时钟源，每一种时钟源的频率都是各不相同的。\n结论：不清楚时钟源的频率，就无法计算总线的频率，从而无法计算挂载在总线下外设的频率。\n可以看到，MCU 提供5 种时钟源，分别是HSI、HSE、LSI、LSE、PLL，每种时钟源的频率都 是不同的。\n(1) HSE 高速外部时钟\n(2) HSI 高速内部时钟\n(3) LSE 低速外部时钟\n(4) LSI 低速内部时钟\n(5) PLL 倍频锁相环\n由于PLL 锁相环是需要HSE 高速外部时钟提供时钟信号，并且PLL 可以把较低的HSE 时钟频率进行放大，则需要用户修改工程中的PLL 参数以及修改工程中的HSE_VALUE\nMCU 主频的计算 = ( HSE_VALUE / PLL_M * PLL_N ) / PLL_P = (8MHz / 8 * 336) / 2 = 168MHz !!!!\n4.时钟选择 通过M3 内核文档可以知道Systick 定时器有2 个时钟源，一个是内部时钟 …","date":"2025-07-23 17:41:58","updated":"2025-07-23 17:41:58"},{"objectID":"1753263718","permalink":"/post/interrupt/","title":"STM32中断、NVIC、EXTI","content":" 一、如何提高程序的实时性 轮询式系统 指的是在程序运行时，首先对所有的硬件进行初始化，然后在主程序中写一个死循环，需要运行的功能按照顺序进行执行，轮询系统是一种简单可靠的方式，一般适用于在只需要按照顺序执行的并且没有外部事件的影响的情况下。程序的运行过程中出现如按键等需要外部检测的事件，轮询系统的实时响应能力变得很差。\nint main() { //1. 对所有的硬件进行初始化（LED、BEEP、KEY......） //2.进入死循环 while(1) { //点灯 //警报 //按键 } } 前后台系统 相比于轮询系统，前后台系统增加中断的概念，如果外部事件发生，则在中断中进行处理，主程序在轮询系统中运行，中断被称为前台，主程序中的while(1)就称为后台。中断会终止后台程序的运行，然后跳转到对应的中断服务函数中去处理，处理完成后，在继续执行后台 的程序。\n//不需要手动调用，当进程捕获到SIGINT 信号时，系统会暂停主程序的执行，来执行该函数 void signal_handler(int signum) { //处理动作 } int main() { //1.对中断进行注册 signal(SIGINT,signal_handler); while(1) { //执行动作，while(1)不允许退出 } } 如果使用前后台系统，可以极大程度的提高程序的实时响应能力，避免造成外部事件的缺失。\n多任务系统 相比于前后台系统，多任务系统的外部事件也是在中断中进行响应，但是外部事件的处理是任务中进行处理。任务具有优先级，优先级高的任务先处理，所以程序就会被分割为一个个的任务，任务是一个独立的死循环，并且不能返回，可以由操作系统进行任务的调度，程序段的实时响应能力又得到提升。\n//任务1 void * task1(void *arg) { while(1) { } } //任务2 void * task2(void *arg) { while(1) { } } int main() { //1.对所有的硬件进行初始化 //2.创建任务，并设置任务的属性(优先级、内存分配、时间片) //3.交给系统的调度器去执行 } 二、外部中断的概述 1.中断的概念 中断指的是CPU 来处理和响应外部发生的异常，中断也就意味着打断，比如打断正在做的事，然后去处理一个紧急的事，处理 …","date":"2025-07-23 17:41:58","updated":"2025-07-23 17:41:58"},{"objectID":"1753177318","permalink":"/post/beepandkey/","title":"STM32 蜂鸣器与触摸按键：原理与应用详解","content":" 一、蜂鸣器的原理与应用 1. 蜂鸣器的分类 蜂鸣器常分为两种：\n有源蜂鸣器 Active Buzzer 内部自带震荡电路 给它直流电即可发声 声音频率固定，无法变调 驱动简单（GPIO 输出高/低即可） 无源蜂鸣器 Passive Buzzer 内部没有震荡电路 需要 MCU 输出不同频率的方波驱动 可产生不同频率（音调） 可以播放旋律 STM32 学习的蜂鸣器有源的，因为接法简单。\n2. 蜂鸣器的硬件原理 以开发板上的蜂鸣器为例：\n一般连接在 MCU 某个 GPIO 引脚上 输出 低电平或高电平 使蜂鸣器导通（根据电路而定） 利用 GPIO 控制发声/停止 典型原理图如下：\n3.使用标准库驱动蜂鸣器 /** ****************************************************************************** * @file beep.c * @author qrshxc@163.com * @version V1.0 * @date 2025.7.22 * @brief 实现 MCU 的 PF8 引脚控制开发板蜂鸣器（有源蜂鸣器） ****************************************************************************** **/ #include \u0026#34;stm32f4xx.h\u0026#34; int main() { /* 定义 GPIO 外设初始化结构体变量 */ GPIO_InitTypeDef GPIO_InitStructure; /* 1. 使能 GPIOF 端口时钟 */ RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE); /* 2. 配置 PF8 为推挽输出 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; // 选择 PF8 引脚 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; // 设置为输出模式 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; // 输出速度 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; // 不上拉、不下拉 GPIO_Init(GPIOF, \u0026amp;GPIO_InitStructure); // 初始化 /* 3. 主循环 */ while(1) { /* 控制 PF8 输出高电平，使蜂鸣器响 */ GPIO_SetBits(GPIOF, GPIO_Pin_8); }\t} 二、按键的原理与应用 机械按键本质上是一个 开关，按下闭合，松开断开。\n按键控制蜂鸣器示例程序 /** ****************************************************************************** * @file key.c * @author qrshxc@163.com * @version V1.0 * @date 2025.7.22 * @brief KEY 控制蜂鸣器示例（PA0 控制 PF8） ****************************************************************************** **/ #include \u0026#34;stm32f4xx.h\u0026#34; /* 蜂鸣器初始化（PF8） */ void Beep_Config() { GPIO_InitTypeDef GPIO_InitStructure; /* 1. 使能 GPIOF 时钟 */ RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE); /* 2. 配置 PF8 为推挽输出 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; GPIO_Init(GPIOF, \u0026amp;GPIO_InitStructure); /* 默认关闭蜂鸣器（低电平） */ GPIO_ResetBits(GPIOF, GPIO_Pin_8); } /* 按键 KEY1 初始化（PA0） */ void Key1_Config() { GPIO_InitTypeDef GPIO_InitStructure; /* 1. 使能 GPIOA 时钟 */ RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); /* 2. 配置 PA0 为输入模式 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); } int main() { /* 初始化蜂鸣器与按键 */ Beep_Config(); Key1_Config(); while(1) { /* 如果 PA0 = 1（按键按下），则蜂鸣器响 */ if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)) { GPIO_SetBits(GPIOF, GPIO_Pin_8); } else { GPIO_ResetBits(GPIOF, GPIO_Pin_8); } } } ","date":"2025-07-22 17:41:58","updated":"2025-07-22 17:41:58"},{"objectID":"1753090918","permalink":"/post/gpio/","title":" STM32 GPIO 入门","content":" 一、GPIO 外设的概述 1.GPIO 的概念 GPIO（General Purpose Input/Output）外设是微控制器中最基本且最通用的接口，用于与外部设备进行交互。GPIO 引脚的核心功能是作为通用的数字输入或输出，可以通过软件配置为多种工作模式，以满足不同的应用需求，GPIO 引脚需要和外设连接在一起的，就可以和外设实现通信以及采集数据等功能。\n2.GPIO 的定义 指的是对芯片的某个引脚进行高低电平的输出，以及可以去检测某个引脚的电平状态。一般电平采用都是 TTL 电平信号，TTL 电平信号规定：+5V 等价于逻辑“1”，0V 等价于逻辑“0”。电平其实有一个电平范围：\u0026amp;gt;2.4V 就表示高电平，\u0026amp;lt;0.4V 就表示低电平。\n3.引脚的布局 电源引脚 ：VCC、VDD、VSS、VDDA、VSSA、VREF+等属于电源引脚 晶振引脚 ：PC14、PC15、PH0、PH1 就属于晶振引脚，也可以作为其他的功能使用 复位引脚 ：NRST 属于复位引脚 BOOT 引脚 ：BOOT0 是专用引脚，BOOT1 就属于功能引脚 （设置芯片的自举模式） GPIO 引脚 ：芯片一共有 144 引脚，但是 GPIO 引脚有 114 个 下载引脚 ：PA13、PA14、PB3、PB4 等都属于下载引脚（JTAG、SWD）\n4.引脚的功能 需要注意：芯片的引脚有很多的功能，一般默认的功能都是作为 GPIO（输入输出），但是引脚也有其他的功能，被称为“第二功能”，只有在使用 ADC 通道和 DAC 需要把引脚设置模拟模式，其他情况下想要把引脚当做别的功能使用，需要把引脚设置复用模式。注意:如果想要了解引脚的功能,应该查阅芯片的数据手册!!!!\n注意:引脚在芯片复位之后的默认功能一般都是 GPIO 功能,但是并不绝对,所以用户在使用后任何一个引脚的时候都应该查阅芯片数据手册.\n二、GPIO 外设的使用 想要学习硬件开发，一般都是从点亮 LED 开始，主要是以基础外设作为入门，掌握外设的控制流程。\n(1) 查看原理图，找到控制发光二极管的芯片的 IO 口，LED0 \u0026amp;ndash; PF9 引脚，其他引脚类似！！\n(2) 分析原理图，理解硬件的控制原理（复杂外设还需要结合数据手册），输出低电平就亮\n(3) 程序设计，根据 ST 公司提供的函数库（标准外设库+HAL 库） …","date":"2025-07-21 17:41:58","updated":"2025-07-21 17:41:58"},{"objectID":"1752918118","permalink":"/post/fileioday5/","title":"文件IO第五天知识","content":"练习：设计程序，实现在LCD 上任意位置显示一张任意大小的色深为24bit 的bmp 图片，要求图像不失真可以在开发板的LCD 上显示。\n练习：设计程序，实现在LCD 上显示一张分辨率为800*480 大小的24bit 的bmp 图片，要求图像不失真可以在开发板的LCD 上显示。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #pragma pack(1) // 定义BMP文件头部结构 typedef struct{ unsigned short bfType; unsigned int bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned int bfOffBits; }BITMAPFILEHEADER; typedef struct{ unsigned int biSize; int biWidth;\t//宽 int biHeight;\t//高 unsigned short biPlanes; unsigned short biBitCount;\t//色深 unsigned int biCompression; unsigned int biSizeImage; int biXPelsPerMeter; int biYPelsPerMeter; unsigned int biClrUsed; unsigned int biClrImportant; }BITMAPINFOHEADER; #pragma pack() int main(int argc, char const *argv[]) { //1.打开待显示的BMP图像 fopen FILE * bmp_fp = fopen(\u0026#34;demo.bmp\u0026#34;,\u0026#34;rb\u0026#34;); if (NULL == bmp_fp) { return -1; } //2.读取BMP文件的图像信息，获取BMP的宽和高 BITMAPINFOHEADER headerinfo; fseek(bmp_fp,14,SEEK_SET); fread(\u0026amp;headerinfo,1,40,bmp_fp); //读取40字节 printf(\u0026#34;bmp width = %d,height = %d\\n\u0026#34;,headerinfo.biWidth,headerinfo.biHeight); //3.读取BMP图*片的颜色分量 800*480*3 char bmp_buf[800*480*3] = {0}; fread(bmp_buf,1,800*480*3,bmp_fp); //4.关闭BMP fclose(bmp_fp); //5.打开LCD open int lcd_fd = open(\u0026#34;/dev/fb0\u0026#34;,O_RDWR); //6.对LCD进行内存映射 mmap int * lcd_mp = (int *)mmap(NULL,800*480*4,PROT_READ|PROT_WRITE,MAP_SHARED,lcd_fd,0); //7.循环的把BMP图像的颜色分量依次写入到LCD的像素点中 int i = 0; int data = 0; for (int y = 480-1; y \u0026gt;= 0; y--) { for (int x = 0; x \u0026lt; 800 ; ++x) { //把BMP图片的一个像素点的颜色分量转换为LCD屏幕的一个像素点的颜色分量格式 ARGB \u0026lt;--- BGR data |= bmp_buf[i];\t//B data |= bmp_buf[i+1]\u0026lt;\u0026lt;8;\t//G data |= bmp_buf[i+2]\u0026lt;\u0026lt;16; //R lcd_mp[800*y + x] = data; //BGR BGR BGR .... i+=3; data = 0; } } //8.关闭LCD close(lcd_fd); munmap(lcd_mp,800*480*4); return 0; } 作业：设计算法，要求把一张任意尺寸的BMP 图片等比例且不失真的缩小为原来的1/2，并生成一张新的BMP 图片，要求BMP 图片的路径都需要通过命令行进行传递\n","date":"2025-07-19 17:41:58","updated":"2025-07-19 17:41:58"},{"objectID":"1752831718","permalink":"/post/fileioday3/","title":"文件IO第三天知识","content":"练习：设计程序，实现在开发板的LCD 屏幕显示三种颜色，拓展：在开发板的LCD 上画一个圆\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { // 1. 打开LCD设备文件 int lcd_fd = open(\u0026#34;/dev/fb0\u0026#34;, O_RDWR); // 修正设备路径为/dev/fb0 if (-1 == lcd_fd) { perror(\u0026#34;open lcd error\u0026#34;); // 使用perror输出更详细的错误信息 exit(1); } // 2. 准备颜色数据并写入LCD int colorbuf[800*480] = {0}; // 800x480分辨率，每个像素4字节 // 分段填充颜色 int i = 0; for (; i \u0026lt; 800*160; ++i) { // 顶部160行黑色 colorbuf[i] = 0x00000000; } for (; i \u0026lt; 800*320; ++i) { // 中间160行红色 colorbuf[i] = 0x00FF0000; } for (; i \u0026lt; 800*480; ++i) { // 底部160行黄色 colorbuf[i] = 0x00FFFF00; } // 写入LCD设备 ssize_t ret = write(lcd_fd, colorbuf, 800*480*4); if (ret == -1) { perror(\u0026#34;write to LCD failed\u0026#34;); close(lcd_fd); exit(1); } // 3. 关闭LCD设备 close(lcd_fd); return 0; } 在开发板的LCD 上画一个圆\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WIDTH 800 // 屏幕宽度 #define HEIGHT 480 // 屏幕高度 #define CENTER_X 400 // 圆心X坐标 #define CENTER_Y 240 // 圆心Y坐标 #define RADIUS 10 // 圆半径 int main() { // 1. 打开FrameBuffer设备 int fb_fd = open(\u0026#34;/dev/fb0\u0026#34;, O_RDWR); if (fb_fd == -1) { perror(\u0026#34;Failed to open framebuffer\u0026#34;); return 1; } // 2. 映射帧缓冲内存 unsigned int *fb_map = mmap(NULL, WIDTH*HEIGHT*4, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0); if (fb_map == MAP_FAILED) { perror(\u0026#34;Failed to mmap framebuffer\u0026#34;); close(fb_fd); return 1; } // 3. 绘制圆形（红色） for (int y = CENTER_Y - RADIUS; y \u0026lt;= CENTER_Y + RADIUS; y++) { for (int x = CENTER_X - RADIUS; x \u0026lt;= CENTER_X + RADIUS; x++) { // 检查像素是否在圆内（圆方程：(x-a)² + (y-b)² ≤ r²） if ((x - CENTER_X)*(x - CENTER_X) + (y - CENTER_Y)*(y - CENTER_Y) \u0026lt;= RADIUS*RADIUS) { // 确保坐标在屏幕范围内 if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; WIDTH \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; HEIGHT) { fb_map[y * WIDTH + x] = 0x00FF0000; // ARGB格式的红色 } } } } // 4. 解除映射并关闭设备 munmap(fb_map, WIDTH*HEIGHT*4); close(fb_fd); return 0; } 练习：设计程序，利用ioctl 函数获取LCD 的硬件参数，把LCD 屏幕的宽和高以及色深的位数输出到屏幕，下载程序到开发板并进行验证。提示：必须包含该头文件\u0026lt;linux/fb.h\u0026gt; !!!!\n#include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;linux/fb.h\u0026gt; int main(int argc, char const *argv[]) { //1.打开LCD int lcd_fd = open(\u0026#34;/dev/fbb\u0026#34;,0_RDWR); //2.利用ioctl函数获取LCD硬件参数 struct fb_var_screeninfo lcd_vinfo; ioctl(lcd_fd,FBIOGET_VSCREENINFO,\u0026amp;led_vinfo); //3.输出LCD的宽、高 printf(\u0026#34;led_height = %d\\n\u0026#34;, lcd_vinfo.vres); //480 printf(\u0026#34;led width = %d\\n\u0026#34;, lcd_vinfo.xres); //800 return 0; } ","date":"2025-07-18 17:41:58","updated":"2025-07-18 17:41:58"},{"objectID":"1752831718","permalink":"/post/fileioday4/","title":"文件IO第四天知识","content":"练习：设计程序，利用系统IO 函数实现让开发板的LCD 屏填充为三色国旗，要求使用内存映射的方式实现，程序设计完成后下载到开发板进行验证并观察效果。\n//假设让LCD显示红色,这个程序需要在开发板中运行 需要交叉编译 arm-linux-gcc #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; int main(int argc, char const *argv[]) { //1.打开LCD 设备文件路径 \u0026#34;/dev/fb0\u0026#34; O_RDWR int lcd_fd = open(\u0026#34;/dev/fb0\u0026#34;,O_RDWR); if (-1 == lcd_fd) { printf(\u0026#34;open lcd error\\n\u0026#34;); return -1; } //2.对LCD进行内存映射 mmap函数 记得接收返回值 int *lcd_mp = (int *)mmap( NULL, 800*480*4, PROT_READ|PROT_WRITE, MAP_SHARED, lcd_fd, 0 ); if (MAP_FAILED == lcd_mp) { printf(\u0026#34;mmap for lcd is error\\n\u0026#34;); return -1; } //3.把颜色分量写入到申请的映射内存空间中，通过地址偏移实现访问 for (int i = 0;i \u0026lt; 800*480; ++i) { lcd_mp[i] = 0x00FF0000; } //4.关闭LCD并解除内存映射 munmap(lcd_mp,800*480*4); close(lcd_fd); return 0; } 练习：设计程序，利用系统IO 读取磁盘上指定BMP 图片的宽和高，以及BMP 图片的大小，并输出到终端，要求图片名称通过命令行传递。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #pragma pack(1) // 禁止内存对齐填充 typedef struct { unsigned short type; // 2字节，\u0026#34;BM\u0026#34;标识 unsigned int size; // 4字节，文件总大小 unsigned short reserved1;// 2字节，保留 unsigned short reserved2;// 2字节，保留 unsigned int offset; // 4字节，数据偏移量 } BMPFileHeader; // 总计14字节 typedef struct { unsigned int header_size; // 4字节，信息头大小(40) int width; // 4字节，图像宽度 int height; // 4字节，图像高度 unsigned short planes; // 2字节，颜色平面数 unsigned short bpp; // 2字节，每像素位数 unsigned int compression; // 4字节，压缩类型 unsigned int image_size; // 4字节，图像数据大小 int x_ppm; // 4字节，水平分辨率 int y_ppm; // 4字节，垂直分辨率 unsigned int colors; // 4字节，颜色数 unsigned int important_colors; // 4字节，重要颜色数 } BMPInfoHeader; // 总计40字节 #pragma pack() // 恢复默认对齐 int main(int argc, char *argv[]) { // 1. 验证参数 if (argc != 2) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;bmp_file\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // 2. 打开文件 int fd = open(argv[1], O_RDONLY); if (fd == -1) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } // 3. 读取文件头 BMPFileHeader fh; if (read(fd, \u0026amp;fh, sizeof(fh)) != 14) { perror(\u0026#34;Error reading file header\u0026#34;); close(fd); return 1; } // 4. 验证BMP格式 if (fh.type != 0x4D42) { // \u0026#34;BM\u0026#34;的十六进制 fprintf(stderr, \u0026#34;Not a valid BMP file\\n\u0026#34;); close(fd); return 1; } // 5. 读取信息头 BMPInfoHeader ih; if (read(fd, \u0026amp;ih, sizeof(ih)) != 40) { perror(\u0026#34;Error reading info header\u0026#34;); close(fd); return 1; } // 6. 输出结果 printf(\u0026#34;BMP File Information:\\n\u0026#34;); printf(\u0026#34; File Path: %s\\n\u0026#34;, argv[1]); printf(\u0026#34; File Size: %u bytes\\n\u0026#34;, fh.size); printf(\u0026#34; Dimensions: %d x %d pixels\\n\u0026#34;, ih.width, ih.height); // 7. 关闭文件 close(fd); return 0; } ","date":"2025-07-18 17:41:58","updated":"2025-07-18 17:41:58"},{"objectID":"1752572518","permalink":"/post/fileioday2/","title":"文件IO第二天知识","content":"练习：要求利用标准IO 函数接口实现计算一个本地磁盘某个文件的大小，要求文件名称通 过命令行进行传递，并进行验证是否正确( ls -l)。\n#include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;stdlib.h\u0026amp;gt; int main(int argc, char const *argv[]) { // 1.要求要计算大小的文件的路径需要通过命令行传递给main()，需要判断用户传递的参数是否有效 if (2 != argc) { printf(\u0026amp;#34;argument is invalid!\\n\u0026amp;#34;); exit(1); } // 2.利用fopen()以只读方式打开需要计算大小的文件 \u0026amp;#34;rb\u0026amp;#34; 以二进制方式打开文件 FILE *fp = fopen(argv[1], \u0026amp;#34;rb\u0026amp;#34;); if (NULL == fp) { perror(\u0026amp;#34;fopen file error\u0026amp;#34;); exit(1); } // 3.计算文本数据大小，可以采用循环计数的方式，每次从文本中读取一个字符，直到文本到达末尾 int cnt = 0; while (1) { if (fgetc(fp) == EOF) { printf(\u0026amp;#34;end of file\\n\u0026amp;#34;); break; } cnt++; } // 4.循环终止，则说明计算完成，此时输出文本大小即可 // printf(\u0026amp;#34;file [%s]: size = %ld \\n\u0026amp;#34;, argv[1], ftell(fp)); // 第二种方法，简单 printf(\u0026amp;#34;file [%s]: size = %d \\n\u0026amp;#34;, argv[1], cnt); // 5.关闭文件 fclose(fp); return 0; } 练习：利用标准IO 函数接口实现文件拷贝，把本地磁盘的文件A 中的数据完整的拷贝到另 一个文本B 中，如果文本B 不存在则创建，要求文本A 的名称和文本B 的名称通过命令行 传递，并进行验证是否正确。\n#include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;strings.h\u0026amp;gt; #include \u0026amp;lt;stdlib.h\u0026amp;gt; //用户缓冲区的大小 #define BUFFERSIZE …","date":"2025-07-15 17:41:58","updated":"2025-07-15 17:41:58"},{"objectID":"1752399718","permalink":"/post/fileioday1/","title":"文件IO第一天知识","content":"练习：在本地磁盘打开一个存储少量数据的文本demo.txt，利用fgetc 函数把文本中的字符 输出到屏幕，当文本中所有字符都输出完成后就结束程序。\n#include \u0026lt;stdio.h\u0026gt; /** * @name :main * @brief :程序主入口，演示文件读取操作 * @param :argc 命令行参数个数 * @param :argv 命令行参数数组 * @return :程序执行状态(0表示成功，-1表示失败) * @date :2025/07/13 * @version :1.0 * @note :该程序打开demo.txt文件并输出其内容到终端 */ int main(int argc, char const *argv[]) { // 1.打开demo.txt FILE *file = fopen(\u0026#34;demo.txt\u0026#34;, \u0026#34;r\u0026#34;); if (NULL == file) { perror(\u0026#34;open demo.txt error\u0026#34;); return -1; } // 2.循环读取文本的字符串输出到终端 int ch = fgetc(file); while (ch != EOF) { printf(\u0026#34;%c\u0026#34;, ch); // 输出已经获取的字符 ch = fgetc(file); } printf(\u0026#34;\\n\u0026#34;); // 3.关闭demo.txt fclose(file); return 0; } 练习：编写一个程序，检测标准IO 的缓冲区的大小。提示：普通文件默认是全缓冲，可以 利用这个特性，一个字节一个字节写入数据，并且在每次写入数据之后获取文件的大小，直 到把缓冲区填满即可测得缓冲区的大小，获取文件信息的函数是stat()。\n/** * @file name : io_buffer_size.c * @brief : 检测标准IO缓冲区大小 * @author : qrshxc@163.com * @date : 2025/07/13 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; /** * @name get_file_size * @brief 获取文件大小 * @param filename 文件名 * @return 文件大小(字节数)，出错返回-1 * @date 2025/07/18 * @version 1.0 * @note 使用stat()函数获取文件信息 */ long get_file_size(const char *filename) { struct stat st; if (stat(filename, \u0026amp;st) == -1) { perror(\u0026#34;stat failed\u0026#34;); return -1; } return st.st_size; } /** * @name detect_buffer_size * @brief 检测标准IO缓冲区大小 * @param filename 测试文件名 * @return 缓冲区大小(字节数)，出错返回-1 * @date 2025/07/13 * @version 1.0 * @note 通过逐个字节写入文件并观察文件大小变化确定缓冲区大小 */ int detect_buffer_size(const char *filename) { FILE *fp = fopen(filename, \u0026#34;w\u0026#34;); if (!fp) { perror(\u0026#34;fopen failed\u0026#34;); return -1; } // 删除可能已存在的文件 unlink(filename); long prev_size = 0; int buffer_size = 0; // 逐个字节写入，直到文件大小变化 for (int i = 1; ; i++) { fputc(\u0026#39;a\u0026#39;, fp); fflush(fp); // 确保写入操作完成 long curr_size = get_file_size(filename); if (curr_size == -1) { fclose(fp); return -1; } if (curr_size \u0026gt; prev_size) { if (prev_size == 0) { // 第一次写入，缓冲区为空 prev_size = curr_size; } else { // 文件大小变化，说明缓冲区已满 buffer_size = i - 1; break; } } } fclose(fp); unlink(filename); // 删除测试文件 return buffer_size; } int main() { const char *test_file = \u0026#34;buffer_test.tmp\u0026#34;; int size = detect_buffer_size(test_file); if (size \u0026gt; 0) { printf(\u0026#34;Standard IO buffer size: %d bytes\\n\u0026#34;, size); } else { printf(\u0026#34;Failed to detect buffer size\\n\u0026#34;); } return 0; } ","date":"2025-07-13 17:41:58","updated":"2025-07-13 17:41:58"},{"objectID":"1746783718","permalink":"/post/bstest/","title":"C语言——数据结构二叉树笔试题","content":"假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有叶子结点数\n/** * @name BinaryTree_CountLeafNode * @brief 计算一棵给定二叉树的所有叶子结点数 * @param root 根节点 * @return\tleftCount + rightCount 叶子结点数 * @retval * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_CountLeafNode(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { // 空树 return 0; }else if ( root-\u0026gt;lchild == NULL \u0026amp;\u0026amp; root-\u0026gt;rchild ==NUll ) { // 只有一个根结点 return 1; }else { int leftCount = BinaryTree_CountLeafNode(root-\u0026gt;lchild); // 左子树的叶子结点数 int rightCount = BinaryTree_CountLeafNode(root-\u0026gt;rchild); // 右子树的叶子结点数 } return leftCount + rightCount; } 假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有结点数\n/** * @name BinaryTree_CountNode * @brief 假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有叶子结点数 * @param root 根结点 * @return * @retval leftCount + rightCount +1 结点数 * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_CountNode(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { return 0; } int leftCount = BinaryTree_CountNode(root-\u0026gt;lchild); // 左子树的叶子结点数 int rightCount = BinaryTree_CountNode(root-\u0026gt;rchild); // 右子树的叶子结点数 return leftCount + rightCount + 1; } 写一个算法求一棵二叉树的深度二叉树以二叉链表为存储方式。\n/** * @name BinaryTree_GetDepth * @brief 求一棵二叉树的深度二叉树以二叉链表为存储方式 * @param root 根节点 * @return\t(leftCount \u0026gt; rightCount ? leftCount : rightCount) + 1 深度 * @retval * @date 2025/05/08 * @version 1.0 * @note */ int BinaryTree_GetDepth(BinaryTree_t *root) { // 递归函数终止条件 if ( root == NULL ) { // 空树 return 0; }else { int leftCount = BinaryTree_CountLeafNode(root-\u0026gt;lchild); // 左子树深度 int rightCount = BinaryTree_CountLeafNode(root-\u0026gt;rchild); // 右子树深度 } return (leftCount \u0026gt; rightCount ? leftCount : rightCount) + 1; } ","date":"2025-05-09 17:41:58","updated":"2025-05-09 17:41:58"},{"objectID":"1746783718","permalink":"/post/stacktoqueue/","title":"C语言笔试题:利用两个栈s1和s2来模拟一个队列","content":"请利用两个栈s1和s2来模拟一个队列，假设栈中元素为int 型，栈中元素最多为 maxSizc。入队:栈的3个运算定义如下。 push(ST,x):元素x入 ST 栈。 pop(ST,\u0026amp;x):ST栈顶元素出栈，赋给变量x。 isEmpty(ST):判断 ST 栈是否为空。 如何利用栈的运算来实现该队列的3个运算:enQueue(元素入队列)、deQueue(元素出队列)、isQueueEmpty(判断队列是否为空，空返回1，不空返回0)。\n// 利用栈s1和s2模拟一个队列，栈的思想是先进后出，队列的思想是后进先出，可以把s1作为入队，s2作为出队 // 入队 bool Enqueue(s1,s2,int x) { int temp; // 用于存储出栈元素的值 // 判断s1是否已满，此时分两种情况（满 or 不满） if( s1-\u0026gt;top + 1 == maxSizc ) { // s1已满，此时有两种情况（栈s2空 or 栈s2不空） // 1.栈s2空 if ( isEmpty(s2) ) { // 把栈s1元素依次入栈s2 while(!isEmpty(s1)) { pop(s1,\u0026amp;temp); // 把栈s1元素暂存temp中 push(s2,temp); // 把temp中的元素入栈到s2 } push(s1,x); // 入栈到s1 return true; }else // 2.栈s2不空 { return false; } }else // 栈s1不满 { push(s1,x); // 直接把x入栈到s1 } return true; } // 出队 bool Dequeue(s1,s2,\u0026amp;x) { int temp; // 用于存储出栈元素 // 判断队列是否为空，此时分两种情况（空 or 不空） if ( isQueueEmpty(s1,s2) ) { return false; }else { // 队列不空，此时分两种情况（栈s2空 or 栈s2不空） if ( !isEmpty(s2) ) { pop(s2,\u0026amp;x); }else { while(!isEmpty(s1)) { pop(s1,\u0026amp;temp); push(s2,temp); } pop(s2,\u0026amp;x) } } return true; } ","date":"2025-05-09 17:41:58","updated":"2025-05-09 17:41:58"},{"objectID":"1746610918","permalink":"/post/test/","title":"C语言——数据结构笔试题","content":"\n已知一个顺序表工，其中的元素递增有序排列，设计一个算法，插入一个元素x(x为int型)后保持该顺序表仍然递增有序排列(假设插入操作总能成功)。\n// 递增排序插入 void SeqList_Insert(SeqList *L, int x) { int temp = -1; // 记录待插入元素的下标 // 遍历顺序表，找到插入位置，比较元素 for (int i = 0; i \u0026lt;= last; ++i) { if (x \u0026lt; L[i]) { temp = i; break; } } if (-1 == temp) { L[last+1] = x; return; } // 把待插入位置的后继元素向后移动 for (int i = last; i \u0026gt;= temp; i--) { L[i+1] = L[i]; } L[temp] = x; // 插入当前位置 } 删除顺序表工中下标为p(0\u0026lt;p\u0026lt;length-1)的元素，成功返回1，否则返回 0，并将被删除元素的值赋给 e。\nint SeqList_Remove(*L, int p) { // 判断L地址是否有效 if( L == NULL ) { return 0; } // 备份待删除元素的值到e中 int e = L[p] // 把待删除元素的后继元素向前移动1单位 for(int i = p;i \u0026lt; length;i++) { L[i] = L[i+1] } return 1; } 设计一个算法删除单链表L(有头结点)中的一个最小值结点\nbool LinkedList_DelMinVal(LinkedList_t *head) { // 判断链表是否为空（只有头结点） if (head == NULL || head-\u0026gt;next == NULL) { return false; } LinkedList_t *prev = head; // 当前结点的前驱 LinkedList_t *current = head-\u0026gt;next; // 当前结点 LinkedList_t *minPrev = prev; // 最小值结点的前驱 LinkedList_t *minNode = current; // 最小值结点 // 遍历链表寻找最小值结点 while (current != NULL) { if (current-\u0026gt;data \u0026lt; minNode-\u0026gt;data) // 比较结点值 { minNode = current; minPrev = prev; } prev = current; current yyyyyyent-\u0026gt;next; } // 删除最小值结点 minPrev-\u0026gt;next = minNode-\u0026gt;next; minNode = NULL; free(minNode); return true; } 1.已知一个带有表头结点的单链表，结点结构为: datanext假设该链表只给出了头指针 head。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k(k为正整数)个位置上的结点。若查找成功，算法输出该结点的data值，并返回 1:否则，只返回 0。\nint findKthToLast(ListNode *head, int k) { // 判断链表是否为空（只有头结点） if (head == NULL || head-\u0026gt;next == NULL) { return 0; } ListNode *p = head; // 慢指针 ListNode *q = head; // 快指针 // 快指针先移动k步 for (int i = 0; i \u0026lt; k; i++) { if (q == NULL) { // 链表长度小于k return 0; } q = q-\u0026gt;next; } // 同时移动两个指针 while (q != NULL) { p = p-\u0026gt;next; q = q-\u0026gt;next; } printf(\u0026#34;倒数第%d个结点的data值为: %d\\n\u0026#34;, k, p-\u0026gt;data); return 1; } ","date":"2025-05-07 17:41:58","updated":"2025-05-07 17:41:58"},{"objectID":"1745833318","permalink":"/post/circularqueue/","title":"C语言循环队列的实现与分析","content":" 引言 队列（Queue）和栈类似，相同点是都属于线性结构，不同点是栈遵循“后进先出”原则，而队列遵循“先进先出”的原则，也被成为“FIFO”结构，就是“First Input First Output”\n数据结构中的队列的两端都允许操作，只不过要求数据只能从队列的一端插入，从队列的另一端删除，可以把队列理解为一根水管，水管有进水口和出水口。一般把允许数据插入的一端称为队尾（Tail或者Rear），一般把允许删除数据的一端称为队头队首（Head或者Front）。\n把允许数据插入的一端称为队尾（允许数据插入到队列的操作称为入队，英文enqueue） 把允许删除数据的一端称为队头（允许数据从队列删除的操作称为出队，英文dequeue） 队列也属于线性结构，所以根据数据元素之间的物理关系来划分的话同样可以以数组或者链表为基础来实现队列的操作。\n以数组为基础实现循环队列 如果以数组为基础，一般会把队列设置为循环队列，循环队列也被称为“环形缓冲区”，因为如果队列中的元素出队，则需要把该元素的后继元素整体向前移动，这是时间复杂度为O(n)的操作。\n如果数据出队之后不去移动后继元素又会导致数组的空间被浪费，为了解决该问题，可以把队列设置为循环队列，在移动数据的时候只需要移一次即可，所以时间复杂度就是O(1)。\n1. 定义数据类型与队列结构 1.1 数据类型定义 循环队列的元素类型可以根据需要进行更改。在此示例中，我们将队列的数据类型定义为 int，并且可以根据需求将其更改为其他类型，如 float 或 char。\n// 循环队列的数据类型 typedef int DataType_t; 1.2 队列结构体定义 我们需要定义一个结构体来管理循环队列的相关信息，包括队列的数据存储、队列的容量、队头和队尾指针。结构体 CirQueue_t 将包含以下成员：\naddr：指向存储数据的数组。 size：队列的最大容量。 rear：队尾指针，指向下一个入队位置。 front：队首指针，指向当前出队的位置。 // 构造循环队列的各项参数（首地址，容量大小，队尾下标，队首下标） typedef struct CircularQueue { DataType_t *addr; // 记录循环队列首元素地址 unsigned int size; // 记录循环队列容量大小 int rear; // …","date":"2025-04-28 17:41:58","updated":"2025-04-28 17:41:58"},{"objectID":"1745660518","permalink":"/post/seqisstrvail/","title":"笔试题：C语言使用顺序栈判断字符串中的括号有效性","content":" 一、背景介绍 通过键盘输入一个包括 \u0026amp;lsquo;(\u0026amp;rsquo; 和 \u0026amp;lsquo;)\u0026amp;rsquo; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。\n我们可以利用 顺序栈（Sequence Stack）来解决这个问题，因为栈结构可以有效地跟踪括号的匹配关系。顺序栈是一个静态实现的栈数据结构，它通过数组实现栈的各项操作，具有较高的时间和空间效率。\n本文将介绍如何使用顺序栈来判断括号是否有效，以下是解决该问题的详细步骤。\n二、算法设计 解决括号匹配问题的基本思路如下：\n入栈操作： 当遇到左括号 ( 时，将其压入栈中。 出栈操作： 当遇到右括号 ) 时，从栈中弹出栈顶元素。 如果栈为空，表示没有对应的左括号，返回无效。 如果弹出的栈顶元素是左括号 (，继续判断下一个字符。 结束后检查栈是否为空： 如果栈不为空，说明有未匹配的左括号，返回无效。 如果栈为空，表示所有括号均有效，返回有效。 版本：\n/** * @file name : SeqenceIsStrVaild.c * @brief : 通过键盘输入一个包括 \u0026amp;#39;(\u0026amp;#39; 和 \u0026amp;#39;)\u0026amp;#39; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件： A. 左括号必须用相同类型的右括号闭合。 B. 左括号必须以正确的顺序闭合。 C. 每个右括号都有一个对应的相同类型的左括号。 * @author : qrshxc@163.com * @date : 2025/04/26 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 三、顺序栈的实现 顺序栈是一种通过数组实现的栈数据结构，通常需要维护三个基本操作：入栈、出栈、检查栈是否为空。\n1. 顺序栈的定义 我们首先定义顺序栈的结构体 SeqStack_t，包括栈底指针、栈容量和栈顶指针。\nc复制编辑typedef char DataType_t; // 栈数据类型 // 顺序栈结构体定义 …","date":"2025-04-26 17:41:58","updated":"2025-04-26 17:41:58"},{"objectID":"1745574118","permalink":"/post/seqstack/","title":"笔试题：C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数","content":" 一、背景介绍 栈是一种特殊的线性表，特殊在栈的一端是封闭的，数据的插入与删除只能在栈的另一端进行，也就是栈遵循“后进先出”的原则。也被成为“LIFO”结构，意思是“last input first output”。\n栈（stack）,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈（PUSH）、出栈（POP）的说法。\n栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。\n闭合的一端被称为栈底（Stack Bottom），允许数据的插入与删除的一端被称为栈顶（Stack Top），不包含任何元素的栈被称为空栈。\n把数据插入到栈空间的动作被称为入栈或者压栈 从栈空间中删除数据的动作被称为出栈或者弹栈 由于栈也是一种线性结构，所以可以以数组或者链表作为基础，在此基础上实现栈的操作。\n以数组作为基础实现栈空间（顺序栈）\n数组在内存中占用一块连续的空间，也就是数组元素的内存地址是连续的。为了实现栈，一般是把数组头作为栈底，数组头部到数组尾部作为栈的增长方向，也就是用户只在数组尾部对数据进行插入和删除。\n以链表作为基础实现栈空间（链式栈）\n如果打算实现链式栈，一般是以链表作为基础，一般是把链表头部作为栈顶，方便数据的插入和删除（头插+头删），链式栈相当于是一个单向不循环的链表。\n本篇博客将展示如何使用顺序栈实现以下功能：\n顺序栈的实现：创建栈、判断栈满与栈空、栈的入栈与出栈操作等。 进制转换：通过栈来实现将十进制数转换为十六进制数。 二、顺序栈的实现 顺序栈使用数组来实现，它包含以下基本操作：\n入栈：将元素压入栈顶。 出栈：从栈顶弹出元素。 判断栈是否为空：栈空时返回true，否则返回false。 判断栈是否满：栈满时返回true，否则返回false。 首先，我们来看看顺序栈的结构和各个操作的实现。\n版本：\n/** * @file name : SequenceStack.c * @brief : C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数 * @author : qrshxc@163.com * @date : 2025/04/24 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 …","date":"2025-04-25 17:41:58","updated":"2025-04-25 17:41:58"},{"objectID":"1745574118","permalink":"/post/bstree/","title":"用 C 语言实现二叉查找树（BST）：插入与遍历","content":"二叉查找树（Binary Search Tree, BST）是一种在查找、插入、删除操作方面效率较高的基础数据结构。它广泛应用于各种算法与系统中，如数据库索引、集合容器等。\n本文将使用 C 语言实现一个完整的 BST，并支持以下功能：\n创建树 插入节点 前序 / 中序 / 后序遍历 项目说明与设计目标 /** * @file name : BST.c * @brief : 设计一个BST二叉查找树，为了方便对二叉树进行增删，所以采用双向不循环链表， * 每个节点的内部都需要有两个指针，分别指向该节点的左子树（lchild）和右子树（rchild） * @author : qrshxc@163.com * @date : 2025/05/08 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 说明： 该程序实现了 BST 的基本结构与插入功能，数据结构设计为每个节点包含一个整型键值，以及两个指向左右子树的指针，便于实现递归插入与遍历操作。\n数据结构定义 // BST树中结点有效键值的数据类型 typedef int DataType_t; // 构造BST树中的结点 typedef struct BSTreeNode { DataType_t data; // 结点的键值 struct BSTreeNode *lchild; // 左子树的指针域 struct BSTreeNode *rchild; // 右子树的指针域 } BSTree_t; 说明：\ndata：当前节点的键值（本例为整型） lchild：指向左子树的指针 rchild：指向右子树的指针 创建节点函数 创建根节点 /** * @name BSTree_Create * @brief 创建一个带键值的根结点，并进行初始化 * @param data 节点的键值 * @return * @retval root 根节点 * @date 2025/05/08 * @version 1.0 * @note */ BSTree_t * BSTree_Create(DataType_t data) { // 给根结点申请一片内存 BSTree_t *root = (BSTree_t …","date":"2025-04-25 17:41:58","updated":"2025-04-25 17:41:58"},{"objectID":"1745401318","permalink":"/post/doublecirlinkedlist/","title":"C语言实现双向循环链表：创建、插入与删除操作","content":"在数据结构中，链表是基础而重要的一部分，而双向链表和循环链表则在一些特定场景下提供了更多灵活性和高效性。今天，我们将探讨如何使用 C 语言实现一个双向循环链表，并实现其基本操作：创建链表、插入节点、删除节点、遍历等。\n双向循环链表的定义 双向链表每个节点都包含三个部分：\n数据域：存储实际数据。 前驱指针：指向当前节点的前一个节点。 后继指针：指向当前节点的下一个节点。 循环特性则意味着链表的尾节点的后继指针指向头节点，头节点的前驱指针指向尾节点。这种结构使得从任意一个节点开始都可以进行完整的遍历。\n/** * @file name : DoubleCircularLinkedList.c * @brief : 实现双向循环链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/23 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要定义链表节点的数据结构。每个节点将包含数据域、前驱指针和后继指针。\n// 单向链表的数据类型 typedef int DataType_t; // 构造链表的节点 typedef struct DoubleCirLinkedList { DataType_t data; // 节点的数据域 struct DoubleCirLinkedList *prev; // 直接前驱的指针域 struct DoubleCirLinkedList *next; // 直接后继的指针域 } DoubleCirLinkedList_t; 我们首先定义一个函数来创建一个空链表并初始化头结点。头结点的 next 和 prev 都指向自己，体现了链表的循环特性。\n/** * @name DoubleCirLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/23 * @version 1.0 * @note 返回初始化的头结点 */ DoubleCirLinkedList_t * …","date":"2025-04-23 17:41:58","updated":"2025-04-23 17:41:58"},{"objectID":"1745228518","permalink":"/post/doublelinkedlist/","title":"C语言实现双向链表：创建、插入与删除操作","content":"在这篇博客中，我们将深入探讨如何用 C 语言实现一个双向链表。我们将逐步实现双向链表的基本操作，包括节点的增、删、查、遍历等，并解释相关的概念与代码实现。与普通链表相比，双向链表的每个节点包含两个指针域：一个指向前一个节点，另一个指向下一个节点，从而使得操作变得更加灵活。\n什么是双向链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而双向链表的特点是： 双向链表中，每个节点不仅包含指向下一个节点的指针，还包含指向前一个节点的指针。这使得双向链表可以在两个方向上进行遍历。 双向链表非常适用于需要在两个方向遍历的数据结构，例如浏览器的前进/后退按钮、双向队列等。 设计双向链表 为了实现双向链表，我们首先需要定义一个链表节点的结构体（DoubleLinkedList_t）。该结构体包含三个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 prev：指向前一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的双向链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : DoubleLinkedList.c * @brief : 实现双向链表的增删查 * @author : qrshxc@163.com * @date : 2025/04/21 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建双向链表 首先，我们需要实现一个函数来创建一个空的双向链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向 NULL，表示链表为空。\n/** * @name DoubleLinkedList_Create * @brief 创建一个空双向链表，并对空链表进行初始化 * @param 无 * @return 头结点地址 * @date 2025/04/19 * @version 1.0 * @note 返回初始化的头结点 */ DoubleLinkedList_t * …","date":"2025-04-21 17:41:58","updated":"2025-04-21 17:41:58"},{"objectID":"1745055718","permalink":"/post/circularlinkedlist/","title":"C语言实现单向循环链表：创建、插入与删除操作","content":"在本篇博客中，我们将深入探讨如何用 C 语言实现一个单向循环链表。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 next 指针指向的是头节点，从而形成了一个闭环。\n什么是循环链表？ 链表是一种常见的数据结构，通常包含多个节点，每个节点包含一个数据元素和一个指向下一个节点的指针。而循环链表的特点是：\n单向循环链表中，最后一个节点的 next 指针不指向 NULL，而是指向头节点。也就是说，遍历链表时，最后会回到头节点，形成一个闭环。 循环链表非常适用于需要重复遍历的数据结构，比如缓冲区、任务调度等。 设计单向循环链表 为了实现单向循环链表，我们首先需要定义一个链表节点的结构体（CircLList_t）。该结构体包含两个成员：\ndata：存储节点的数据。 next：指向下一个节点的指针。 接下来，我们将实现几个基本操作：\n链表创建：创建一个空的单向循环链表。 节点插入：在链表的头部、尾部或指定位置插入节点。 节点删除：删除链表中的指定节点（头节点、尾节点或指定值节点）。 链表遍历：遍历并打印链表中的所有节点。 版本：\n/** * @file name : CircularLinkedList.c * @brief : 实现单向循环链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/18 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 创建单向循环链表 首先，我们需要实现一个函数来创建一个空的单向循环链表，并返回链表的头结点。头结点不存储实际数据，它的 next 指针指向自己，表示链表为空。\n/** * @name CircularLinkedList_Create * @brief 创建一个空单项循环链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/18 * @version 1.0 * @note */ CircularLinkedList * …","date":"2025-04-19 17:41:58","updated":"2025-04-19 17:41:58"},{"objectID":"1744710118","permalink":"/post/linkedlist/","title":"用 C 语言实现单向链表","content":"在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。\n版本：\n链表基础知识 链表是一种数据结构，它由一系列节点（Node）构成，每个节点包含两个部分：\n数据域（Data）：存储实际的数据。 指针域（Next）：指向下一个节点的指针。 单向链表 单向链表是最简单的链表形式，每个节点只有一个指针域，指向下一个节点。最后一个节点的指针域为空（NULL），表示链表的结尾。\n实现单向链表 我们将实现以下几个功能：\n链表创建：创建一个空的链表。 节点插入：支持头部插入、尾部插入和指定位置插入。 节点删除：删除链表中的指定节点。 查找节点：查找链表中是否包含指定数据的节点。 更新节点：修改链表中指定节点的数据。 遍历链表：遍历并打印链表中的所有节点。 /** * @file name : LinkedList.c * @brief : 实现链表的增删改查 * @author : qrshxc@163.com * @date : 2025/04/09 * @version : 1.0 * @note : * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 1. 链表创建 链表的创建首先需要创建一个头节点。头节点不存储实际数据，但它是链表的起点，所有的操作都需要从头节点开始。我们使用 calloc 动态分配内存来创建头节点。\n/** * @name LinkedList_Create * @brief 创建一个空链表，并对空链表进行初始化 * @param * @return * @retval head 头结点地址 * @date 2025/04/09 * @version 1.0 * @note */ LinkedList_t *LinkedList_Create(void) { //给头结点申请一片内存 LinkedList_t * head = (LinkedList_t *)calloc(1,sizeof(LinkedList_t)); //错误处理 if (head == NULL) { …","date":"2025-04-15 17:41:58","updated":"2025-04-15 17:41:58"},{"objectID":"1744191718","permalink":"/post/sequencelist/","title":"数据结构-顺序表的增、删、改、查（C语言版）","content":"顺序表指的是使用一组内存地址连续的内存单元来依次存储线性表中的数据元素，使用这种存储结构的线性表就被称为顺序表。\n简单理解：数据存储在一块连续的内存中，在C 语言中可以具名的数组，也可以使用匿名的数组（堆内存）。\n顺序表的特点：数据元素之间的逻辑关系是相邻的，并且内存地址也是相邻的，所以只要知道存储线性表的第一个数据元素的内存地址，就可以对线性表中的任意一个元素进行随机访问。通常用户使用动态分配的数组来实现顺序表,也就是使用堆内存实现。\n版本：\n/** * @file name : SequenceList.c * @brief : 实现顺序表元素的增删改查 * @author : qrshxc@163.com * @date : 2025/04/07 * @version : 1.0 * @note : 模块化实现 * CopyRight (c) 2025-2026 qrshxc@163.com All Right Reseverd */ 顺序表的结构定义 首先，我们需要定义一个结构体来表示顺序表，包括数据类型和数据表各项参数等信息：\ntypedef int DataType_t; //构造顺序表SquenceList各项参数（顺序表的首地址，容量大小，有效元素最后的下标） typedef struct SequenceList { DataType_t *addr;//记录顺序表首元素地址 unsigned int size;//记录顺序表容量大小 int last;//记录顺序表有效元素最后下标 }SeqList_t; 创建一个空顺序表 创建顺序表并对顺序表进行初始化\n/** * @name SeqList_create * @brief 创建顺序表并对顺序表进行初始化 * @param size 顺序表的大小 * @return * @retval manager 顺序表的管理结构体 * @date 2025/04/07 * @version 1.0 * @note Manager-\u0026amp;gt;Addr ---\u0026amp;gt; [Size*sizeof(DataType_t)] */ SeqList_t *SeqList_create(unsigned size) { // 1.利用calloc给管理结构体manager申请一块堆内存 SeqList_t …","date":"2025-04-09 17:41:58","updated":"2025-04-09 17:41:58"}]