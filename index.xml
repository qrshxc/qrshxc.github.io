<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>九思的博客</title><link>https://qrshxc.github.io/algolia.json</link><description>Recent content on 九思的博客</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 08 Aug 2025 17:41:58 +0800</lastBuildDate><atom:link href="https://qrshxc.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>嵌入式实时系统的核心原理与 FreeRTOS 移植指南</title><link>https://qrshxc.github.io/post/freertos/</link><pubDate>Fri, 08 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/freertos/</guid><description>&lt;h1 id="一rtos的基本概念"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80rtos%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
一、RTOS的基本概念
&lt;/h1&gt;&lt;p&gt;实时操作系统（Real Time Operating System）的简称就叫做RTOS，是指具有&lt;strong&gt;实时性&lt;/strong&gt;、能支持实时控制系统工作的操作系统，RTOS的首要任务就是调度所有可以利用的资源来完成实时控制任务的工作，其次才是提高工作效率。&lt;/p&gt;</description></item><item><title>RFID 多标签防碰撞机制深度解析：读写器如何从多张卡片中准确选中一张？</title><link>https://qrshxc.github.io/post/acm/</link><pubDate>Thu, 07 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/acm/</guid><description>&lt;p&gt;在各种实际应用场景中，RFID 技术往往需要面对多个标签同时进入射频场的复杂情况。无论是地铁闸机、高速仓储线上的商品标签，还是智能门禁系统，如果读写器无法从同时存在的多张标签中准确识别出某一张要进行读写的标签，那么整套系统就会变得不稳定甚至失效。因此，如何在多标签并发的情况下保持通信的有序和可靠，就成为 RFID 技术中不可绕开的核心问题，这也催生了所谓的“防碰撞机制”。&lt;/p&gt;</description></item><item><title>IIC总线通信与AT24C02存储芯片及OLED屏应用详解</title><link>https://qrshxc.github.io/post/iic/</link><pubDate>Tue, 05 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/iic/</guid><description>&lt;h1 id="一内部集成电路概述"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e5%86%85%e9%83%a8%e9%9b%86%e6%88%90%e7%94%b5%e8%b7%af%e6%a6%82%e8%bf%b0"&gt;&lt;/a&gt;
一、内部集成电路概述
&lt;/h1&gt;&lt;h2 id="1-基本概念"&gt;
&lt;a class="header-anchor" href="#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
1. 基本概念
&lt;/h2&gt;&lt;p&gt;内部集成电路（Inter Integrated Circuit）的简称叫做IIC 或者I2C，是一种简单的、半双工同步通信的串行通信接口，IIC 总线是上世纪80 年代（1982 年）由飞利浦公司设计出来，当时的目的是为了给MCU 和外围芯片提供更简单的交互方式。&lt;/p&gt;</description></item><item><title>STM32与RFID模块(MFRC522)完全应用指南</title><link>https://qrshxc.github.io/post/rfid/</link><pubDate>Mon, 04 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/rfid/</guid><description>&lt;h1 id="一rfid-模块的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80rfid-%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、RFID 模块的原理与应用
&lt;/h1&gt;&lt;h2 id="1-基本概念"&gt;
&lt;a class="header-anchor" href="#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
1. 基本概念
&lt;/h2&gt;&lt;p&gt;RFID 技术也简称为射频识别技术，是20 世纪40 年代开始出现的一种自动识别技术。RFID通过无线射频信号获取物体的相关数据，并对物体加以识别，RFID 技术不需要和被识别物体进行直接接触就可以完成物体信息的处理，也不需要人工干预，可以实现无接触式信息传递，能应用在各种较为恶劣的环境中。所以说RFID 技术是一种快速、高效的采集和处理物体信息的自动识别技术。&lt;/p&gt;</description></item><item><title>STM32 SPI接口与Flash存储芯片完全指南</title><link>https://qrshxc.github.io/post/spiflash/</link><pubDate>Sun, 03 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/spiflash/</guid><description>&lt;h1 id="一串行外设接口spi深度解析"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e4%b8%b2%e8%a1%8c%e5%a4%96%e8%ae%be%e6%8e%a5%e5%8f%a3spi%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"&gt;&lt;/a&gt;
一、串行外设接口(SPI)深度解析
&lt;/h1&gt;&lt;p&gt;单总线协议指的是只采用一根信道来进行数据传输，通信指的是双方（MCU 与传感器）通过一根信道进行数据交互，所以按照数据的传输方向，只能采用半双工通信方式，比较典型的传感器就是温度传感器（DS18B20、DHT11&amp;hellip;&amp;hellip;）&lt;/p&gt;</description></item><item><title>单总线协议的原理和DHT11的应用</title><link>https://qrshxc.github.io/post/dht11/</link><pubDate>Fri, 01 Aug 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/dht11/</guid><description>&lt;h1 id="一单总线协议的原理和应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e5%8d%95%e6%80%bb%e7%ba%bf%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8e%9f%e7%90%86%e5%92%8c%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、单总线协议的原理和应用
&lt;/h1&gt;&lt;p&gt;单总线协议指的是只采用一根信道来进行数据传输，通信指的是双方（MCU 与传感器）通过一根信道进行数据交互，所以按照数据的传输方向，只能采用半双工通信方式，比较典型的传感器就是温度传感器（DS18B20、DHT11&amp;hellip;&amp;hellip;）&lt;/p&gt;</description></item><item><title>STM32看门狗与RTC实时时钟完全指南</title><link>https://qrshxc.github.io/post/iwdgrtc/</link><pubDate>Wed, 30 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/iwdgrtc/</guid><description>&lt;h1 id="一看门狗外设的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e7%9c%8b%e9%97%a8%e7%8b%97%e5%a4%96%e8%ae%be%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、看门狗外设的原理与应用
&lt;/h1&gt;&lt;p&gt;随着单片机的发展，单片机在家用电器、工业自动化、生产过程控制、智能仪器仪表等领域的应用越来越广泛。然而处于同一电力系统中的各种电气设备通过电或磁的联系彼此紧密相连，相互影响，由于运行方式的改变、故障、开关操作等引起的电磁振荡会波及很多电气设备。这对我们单片机系统的可靠性与安全性构成了极大的威胁。单片机测控系统必须长期稳定、可靠运行，否则将导致控制误差加大，严重时会使系统失灵，甚至造成巨大损失。因此单片机的抗干扰能力已经成为不容忽视的问题。&lt;/p&gt;</description></item><item><title>STM32模数转换器(ADC)原理与应用完全指南 -——光敏电阻</title><link>https://qrshxc.github.io/post/light/</link><pubDate>Tue, 29 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/light/</guid><description>&lt;h1 id="一模数转换的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e6%a8%a1%e6%95%b0%e8%bd%ac%e6%8d%a2%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、模数转换的原理与应用
&lt;/h1&gt;&lt;p&gt;一般在电子线路中，信号分为两种：模拟信号 + 数字信号，大多数传感器采集的都是模拟信号，比如温度、湿度、压力&amp;hellip;&amp;hellip;. ，采集的模拟信号再转交给计算机进行处理，计算机处理的是数字信号，其中涉及到模拟量和数字量的转换，会使用模数转换器，也被称为ADC。&lt;/p&gt;</description></item><item><title>STM32蓝牙模块的原理与应用</title><link>https://qrshxc.github.io/post/ble/</link><pubDate>Mon, 28 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/ble/</guid><description>&lt;p&gt;一般MCU 和计算机通信是采用有线方式实现，这种方案的缺点是实用性较差，无法实现良好的人机交互，所以正常应该是采用无线通信的方式实现对MCU 的控制，一般主流的无线通信方式有BLE、WIFI、Zigbee、LoRa，其中Zigbee、LoRa 可以实现组网通信，其实BLE 蓝牙也可以实现组网通信，当然蓝牙除了组网之外，最常用就是方案就是利用手机远程控制硬件。&lt;/p&gt;</description></item><item><title>STM32串口通信</title><link>https://qrshxc.github.io/post/usart/</link><pubDate>Sun, 27 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/usart/</guid><description>&lt;h1 id="一串口通信的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e4%b8%b2%e5%8f%a3%e9%80%9a%e4%bf%a1%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、串口通信的原理与应用
&lt;/h1&gt;&lt;h3 id="1-通信的方式"&gt;
&lt;a class="header-anchor" href="#1-%e9%80%9a%e4%bf%a1%e7%9a%84%e6%96%b9%e5%bc%8f"&gt;&lt;/a&gt;
1. 通信的方式
&lt;/h3&gt;&lt;p&gt;处理器与外部设备之间或者处理器与处理器之间通信的方式分两种：串行通信和并行通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行通信&lt;/strong&gt;
传输原理：数据按位依次顺序传输（每一位占据固定的时间长度 MSB or LSB）
优点：占用引脚资源少、成本低、传输距离远
缺点：速度慢
应用场合：常用于工控、测量设备，以及部分通信设备 如 USB、COM 口&lt;/p&gt;</description></item><item><title>STM32定时器：从基础定时到PWM高级应用</title><link>https://qrshxc.github.io/post/pwm/</link><pubDate>Fri, 25 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/pwm/</guid><description>&lt;h1 id="一stm32-基本定时器的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80stm32-%e5%9f%ba%e6%9c%ac%e5%ae%9a%e6%97%b6%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、STM32 基本定时器的原理与应用
&lt;/h1&gt;&lt;h2 id="1-基本概念"&gt;
&lt;a class="header-anchor" href="#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
1. 基本概念
&lt;/h2&gt;&lt;p&gt;定时器的作用一般是为了使用定时功能和中断功能（洗衣机、微波炉&amp;hellip;..），当然在STM32中也可以利用定时器产生周期性的脉冲信号来控制不同的外设（灯的亮度、电机的转速、舵机的角度&amp;hellip;&amp;hellip;），所以掌握STM32 中的定时器对于项目开发是很有必要的。&lt;/p&gt;</description></item><item><title>STM32系统时钟与SysTick定时器</title><link>https://qrshxc.github.io/post/timer/</link><pubDate>Wed, 23 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/timer/</guid><description>&lt;h1 id="一系统嘀嗒定时器systick全面解析"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e7%b3%bb%e7%bb%9f%e5%98%80%e5%97%92%e5%ae%9a%e6%97%b6%e5%99%a8systick%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90"&gt;&lt;/a&gt;
一、系统嘀嗒定时器(SysTick)全面解析
&lt;/h1&gt;&lt;h3 id="1-systick定时器基本概念"&gt;
&lt;a class="header-anchor" href="#1-systick%e5%ae%9a%e6%97%b6%e5%99%a8%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
1. SysTick定时器基本概念
&lt;/h3&gt;&lt;p&gt;定时器是STM32 中常用的外设，一般定时器的基本功能就是定时，而在Cortex M3/M4 内核中也包含一个简单的定时器，就是系统嘀嗒定时器(Systick)，它是属于M4 内核的一个外设，内嵌在NVIC 中，所有基于Cortex-M3/M4 内核的MCU 中都包含这个Systick 定时器，所以在不同的硬件中移植起来非常方便。
由于Systick 定时器属于CM4内核，所以大家在STM32F4 中文参考手册中是找不到关于Systick时器的相关信息，所以可以在CM3 权威指南或者Cortex M3/M4 权威指南中找到。&lt;/p&gt;</description></item><item><title>STM32中断、NVIC、EXTI</title><link>https://qrshxc.github.io/post/interrupt/</link><pubDate>Wed, 23 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/interrupt/</guid><description>&lt;h1 id="一如何提高程序的实时性"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e5%a6%82%e4%bd%95%e6%8f%90%e9%ab%98%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%ae%9e%e6%97%b6%e6%80%a7"&gt;&lt;/a&gt;
一、如何提高程序的实时性
&lt;/h1&gt;&lt;h2 id="轮询式系统"&gt;
&lt;a class="header-anchor" href="#%e8%bd%ae%e8%af%a2%e5%bc%8f%e7%b3%bb%e7%bb%9f"&gt;&lt;/a&gt;
轮询式系统
&lt;/h2&gt;&lt;p&gt;指的是在程序运行时，首先对所有的硬件进行初始化，然后在主程序中写一个死循环，需要运行的功能按照顺序进行执行，轮询系统是一种简单可靠的方式，一般适用于在只需要按照顺序执行的并且没有外部事件的影响的情况下。程序的运行过程中出现如按键等需要外部检测的事件，轮询系统的实时响应能力变得很差。&lt;/p&gt;</description></item><item><title>STM32 蜂鸣器与触摸按键：原理与应用详解</title><link>https://qrshxc.github.io/post/beepandkey/</link><pubDate>Tue, 22 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/beepandkey/</guid><description>&lt;h1 id="一蜂鸣器的原理与应用"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e8%9c%82%e9%b8%a3%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ba%94%e7%94%a8"&gt;&lt;/a&gt;
一、蜂鸣器的原理与应用
&lt;/h1&gt;&lt;h2 id="1-蜂鸣器的分类"&gt;
&lt;a class="header-anchor" href="#1-%e8%9c%82%e9%b8%a3%e5%99%a8%e7%9a%84%e5%88%86%e7%b1%bb"&gt;&lt;/a&gt;
1. 蜂鸣器的分类
&lt;/h2&gt;&lt;p&gt;蜂鸣器常分为两种：&lt;/p&gt;
&lt;h4 id="有源蜂鸣器-active-buzzer"&gt;
&lt;a class="header-anchor" href="#%e6%9c%89%e6%ba%90%e8%9c%82%e9%b8%a3%e5%99%a8-active-buzzer"&gt;&lt;/a&gt;
有源蜂鸣器 Active Buzzer
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内部自带震荡电路&lt;/li&gt;
&lt;li&gt;给它直流电即可发声&lt;/li&gt;
&lt;li&gt;声音频率固定，无法变调&lt;/li&gt;
&lt;li&gt;驱动简单（GPIO 输出高/低即可）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="无源蜂鸣器-passive-buzzer"&gt;
&lt;a class="header-anchor" href="#%e6%97%a0%e6%ba%90%e8%9c%82%e9%b8%a3%e5%99%a8-passive-buzzer"&gt;&lt;/a&gt;
无源蜂鸣器 Passive Buzzer
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内部没有震荡电路&lt;/li&gt;
&lt;li&gt;需要 MCU 输出不同频率的方波驱动&lt;/li&gt;
&lt;li&gt;可产生不同频率（音调）&lt;/li&gt;
&lt;li&gt;可以播放旋律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;STM32 学习的蜂鸣器有源的，因为接法简单。&lt;/p&gt;</description></item><item><title> STM32 GPIO 入门</title><link>https://qrshxc.github.io/post/gpio/</link><pubDate>Mon, 21 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/gpio/</guid><description>&lt;h1 id="一gpio-外设的概述"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80gpio-%e5%a4%96%e8%ae%be%e7%9a%84%e6%a6%82%e8%bf%b0"&gt;&lt;/a&gt;
一、GPIO 外设的概述
&lt;/h1&gt;&lt;h3 id="1gpio-的概念"&gt;
&lt;a class="header-anchor" href="#1gpio-%e7%9a%84%e6%a6%82%e5%bf%b5"&gt;&lt;/a&gt;
1.GPIO 的概念
&lt;/h3&gt;&lt;p&gt;GPIO（General Purpose Input/Output）外设是微控制器中最基本且最通用的接口，用于与外部设备进行交互。GPIO 引脚的核心功能是作为通用的数字输入或输出，可以通过软件配置为多种工作模式，以满足不同的应用需求，GPIO 引脚需要和外设连接在一起的，就可以和外设实现通信以及采集数据等功能。&lt;/p&gt;</description></item><item><title>文件IO第五天知识</title><link>https://qrshxc.github.io/post/fileioday5/</link><pubDate>Sat, 19 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/fileioday5/</guid><description>&lt;p&gt;练习：设计程序，实现在LCD 上任意位置显示一张任意大小的色深为24bit 的bmp 图片，要求图像不失真可以在开发板的LCD 上显示。&lt;/p&gt;
&lt;p&gt;练习：设计程序，实现在LCD 上显示一张分辨率为800*480 大小的24bit 的bmp 图片，要求图像不失真可以在开发板的LCD 上显示。&lt;/p&gt;</description></item><item><title>文件IO第三天知识</title><link>https://qrshxc.github.io/post/fileioday3/</link><pubDate>Fri, 18 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/fileioday3/</guid><description>&lt;p&gt;练习：设计程序，实现在开发板的LCD 屏幕显示三种颜色，拓展：在开发板的LCD 上画一个圆&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 1. 打开LCD设备文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lcd_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;/dev/fb0&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_RDWR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 修正设备路径为/dev/fb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;lcd_fd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;open lcd error&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 使用perror输出更详细的错误信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nf"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 2. 准备颜色数据并写入LCD
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;colorbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 800x480分辨率，每个像素4字节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 分段填充颜色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 顶部160行黑色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;colorbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;320&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 中间160行红色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;colorbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x00FF0000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 底部160行黄色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;colorbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x00FFFF00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 写入LCD设备
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lcd_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;colorbuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;write to LCD failed&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lcd_fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 3. 关闭LCD设备
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lcd_fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在开发板的LCD 上画一个圆&lt;/p&gt;</description></item><item><title>文件IO第四天知识</title><link>https://qrshxc.github.io/post/fileioday4/</link><pubDate>Fri, 18 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/fileioday4/</guid><description>&lt;p&gt;练习：设计程序，利用系统IO 函数实现让开发板的LCD 屏填充为三色国旗，要求使用内存映射的方式实现，程序设计完成后下载到开发板进行验证并观察效果。&lt;/p&gt;</description></item><item><title>文件IO第二天知识</title><link>https://qrshxc.github.io/post/fileioday2/</link><pubDate>Tue, 15 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/fileioday2/</guid><description>&lt;p&gt;练习：要求利用标准IO 函数接口实现计算一个本地磁盘某个文件的大小，要求文件名称通
过命令行进行传递，并进行验证是否正确( ls -l)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 1.要求要计算大小的文件的路径需要通过命令行传递给main()，需要判断用户传递的参数是否有效
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;argument is invalid!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 2.利用fopen()以只读方式打开需要计算大小的文件 &amp;#34;rb&amp;#34; 以二进制方式打开文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;fopen file error&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 3.计算文本数据大小，可以采用循环计数的方式，每次从文本中读取一个字符，直到文本到达末尾
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fgetc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;end of file&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 4.循环终止，则说明计算完成，此时输出文本大小即可
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// printf(&amp;#34;file [%s]: size = %ld \n&amp;#34;, argv[1], ftell(fp)); // 第二种方法，简单
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;file [%s]: size = %d &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 5.关闭文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nf"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;练习：利用标准IO 函数接口实现文件拷贝，把本地磁盘的文件A 中的数据完整的拷贝到另
一个文本B 中，如果文本B 不存在则创建，要求文本A 的名称和文本B 的名称通过命令行
传递，并进行验证是否正确。&lt;/p&gt;</description></item><item><title>文件IO第一天知识</title><link>https://qrshxc.github.io/post/fileioday1/</link><pubDate>Sun, 13 Jul 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/fileioday1/</guid><description>&lt;p&gt;练习：在本地磁盘打开一个存储少量数据的文本demo.txt，利用fgetc 函数把文本中的字符
输出到屏幕，当文本中所有字符都输出完成后就结束程序。&lt;/p&gt;</description></item><item><title>C语言——数据结构二叉树笔试题</title><link>https://qrshxc.github.io/post/bstest/</link><pubDate>Fri, 09 May 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/bstest/</guid><description>&lt;p&gt;假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有叶子结点数&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/qrshxc/img/main/imgsimage-20250509205207054.png" alt=""&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @name BinaryTree_CountLeafNode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @brief 计算一棵给定二叉树的所有叶子结点数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @param root 根节点 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @return	 leftCount + rightCount 叶子结点数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @retval 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @date 2025/05/08
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @version 1.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * @note 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;BinaryTree_CountLeafNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryTree_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="c1"&gt;// 递归函数终止条件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;	&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;		&lt;span class="c1"&gt;// 空树
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;		&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;NUll&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;		&lt;span class="c1"&gt;// 只有一个根结点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;		&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;		&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;leftCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;BinaryTree_CountLeafNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 左子树的叶子结点数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;		&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rightCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;BinaryTree_CountLeafNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 右子树的叶子结点数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;leftCount&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rightCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设二叉树采用二叉链存储结构，设计一个算法，计算一棵给定二叉树的所有结点数&lt;/p&gt;</description></item><item><title>C语言笔试题:利用两个栈s1和s2来模拟一个队列</title><link>https://qrshxc.github.io/post/stacktoqueue/</link><pubDate>Fri, 09 May 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/stacktoqueue/</guid><description>&lt;p&gt;请利用两个栈s1和s2来模拟一个队列，假设栈中元素为int 型，栈中元素最多为 maxSizc。入队:栈的3个运算定义如下。
push(ST,x):元素x入 ST 栈。
pop(ST,&amp;amp;x):ST栈顶元素出栈，赋给变量x。
isEmpty(ST):判断 ST 栈是否为空。
如何利用栈的运算来实现该队列的3个运算:enQueue(元素入队列)、deQueue(元素出队列)、isQueueEmpty(判断队列是否为空，空返回1，不空返回0)。&lt;/p&gt;</description></item><item><title>C语言——数据结构笔试题</title><link>https://qrshxc.github.io/post/test/</link><pubDate>Wed, 07 May 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/test/</guid><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/qrshxc/img/main/imgsimage-20250506231344924.png" alt="image-20250506231344924"&gt;&lt;/p&gt;
&lt;p&gt;已知一个顺序表工，其中的元素递增有序排列，设计一个算法，插入一个元素x(x为int型)后保持该顺序表仍然递增有序排列(假设插入操作总能成功)。&lt;/p&gt;</description></item><item><title>C语言循环队列的实现与分析</title><link>https://qrshxc.github.io/post/circularqueue/</link><pubDate>Mon, 28 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/circularqueue/</guid><description>&lt;hr&gt;
&lt;h1 id="引言"&gt;
&lt;a class="header-anchor" href="#%e5%bc%95%e8%a8%80"&gt;&lt;/a&gt;
引言
&lt;/h1&gt;&lt;p&gt;队列（Queue）和栈类似，相同点是都属于线性结构，不同点是栈遵循“后进先出”原则，而队列遵循“先进先出”的原则，也被成为“FIFO”结构，就是“First Input First Output”&lt;/p&gt;</description></item><item><title>笔试题：C语言使用顺序栈判断字符串中的括号有效性</title><link>https://qrshxc.github.io/post/seqisstrvail/</link><pubDate>Sat, 26 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/seqisstrvail/</guid><description>&lt;h1 id="一背景介绍"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d"&gt;&lt;/a&gt;
一、背景介绍
&lt;/h1&gt;&lt;p&gt;通过键盘输入一个包括 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串string ，判断字符串是否有效。要求设计算法实现检查字符串是否有效，有效的字符串需满足以下条件：
A. 左括号必须用相同类型的右括号闭合。
B. 左括号必须以正确的顺序闭合。
C. 每个右括号都有一个对应的相同类型的左括号。&lt;/p&gt;</description></item><item><title>笔试题：C语言实现顺序栈与进制转换的实现 —— 十进制数转十六进制数</title><link>https://qrshxc.github.io/post/seqstack/</link><pubDate>Fri, 25 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/seqstack/</guid><description>&lt;h1 id="一背景介绍"&gt;
&lt;a class="header-anchor" href="#%e4%b8%80%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d"&gt;&lt;/a&gt;
一、背景介绍
&lt;/h1&gt;&lt;p&gt;栈是一种特殊的线性表，特殊在栈的一端是封闭的，数据的插入与删除只能在栈的另一端进行，也就是栈遵循“后进先出”的原则。也被成为“LIFO”结构，意思是“last input first output”。&lt;/p&gt;</description></item><item><title>用 C 语言实现二叉查找树（BST）：插入与遍历</title><link>https://qrshxc.github.io/post/bstree/</link><pubDate>Fri, 25 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/bstree/</guid><description>&lt;p&gt;二叉查找树（Binary Search Tree, BST）是一种在&lt;strong&gt;查找、插入、删除操作&lt;/strong&gt;方面效率较高的基础数据结构。它广泛应用于各种算法与系统中，如数据库索引、集合容器等。&lt;/p&gt;</description></item><item><title>C语言实现双向循环链表：创建、插入与删除操作</title><link>https://qrshxc.github.io/post/doublecirlinkedlist/</link><pubDate>Wed, 23 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/doublecirlinkedlist/</guid><description>&lt;p&gt;在数据结构中，链表是基础而重要的一部分，而双向链表和循环链表则在一些特定场景下提供了更多灵活性和高效性。今天，我们将探讨如何使用 C 语言实现一个双向循环链表，并实现其基本操作：创建链表、插入节点、删除节点、遍历等。&lt;/p&gt;</description></item><item><title>C语言实现双向链表：创建、插入与删除操作</title><link>https://qrshxc.github.io/post/doublelinkedlist/</link><pubDate>Mon, 21 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/doublelinkedlist/</guid><description>&lt;p&gt;在这篇博客中，我们将深入探讨如何用 C 语言实现一个&lt;strong&gt;双向链表&lt;/strong&gt;。我们将逐步实现双向链表的基本操作，包括节点的增、删、查、遍历等，并解释相关的概念与代码实现。与普通链表相比，双向链表的每个节点包含两个指针域：一个指向前一个节点，另一个指向下一个节点，从而使得操作变得更加灵活。&lt;/p&gt;</description></item><item><title>C语言实现单向循环链表：创建、插入与删除操作</title><link>https://qrshxc.github.io/post/circularlinkedlist/</link><pubDate>Sat, 19 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/circularlinkedlist/</guid><description>&lt;p&gt;在本篇博客中，我们将深入探讨如何用 C 语言实现一个&lt;strong&gt;单向循环链表&lt;/strong&gt;。我们将逐步实现循环链表的基本操作，包括节点的增、删、改、查和遍历等，并解释相关的概念与代码实现。单向循环链表与普通链表的区别在于最后一个节点的 &lt;code&gt;next&lt;/code&gt; 指针指向的是头节点，从而形成了一个闭环。&lt;/p&gt;</description></item><item><title>用 C 语言实现单向链表</title><link>https://qrshxc.github.io/post/linkedlist/</link><pubDate>Tue, 15 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/linkedlist/</guid><description>&lt;p&gt;在这篇文章中，我们将通过 C 语言实现一个简单的单向链表，并实现几个常用的链表操作，包括链表的创建、节点插入、删除、查找、更新以及打印等功能。链表是一个非常重要的线性数据结构，它与数组相比具有动态存储优势，因此在实际开发中广泛应用。&lt;/p&gt;</description></item><item><title>数据结构-顺序表的增、删、改、查（C语言版）</title><link>https://qrshxc.github.io/post/sequencelist/</link><pubDate>Wed, 09 Apr 2025 17:41:58 +0800</pubDate><guid>https://qrshxc.github.io/post/sequencelist/</guid><description>&lt;p&gt;顺序表指的是使用一组内存地址连续的内存单元来依次存储线性表中的数据元素，使用这种存储结构的线性表就被称为顺序表。&lt;/p&gt;
&lt;p&gt;简单理解：数据存储在一块连续的内存中，在C 语言中可以具名的数组，也可以使用匿名的数组（堆内存）。&lt;/p&gt;</description></item><item><title>关于</title><link>https://qrshxc.github.io/about/</link><pubDate>Fri, 04 Apr 2025 20:12:52 +0800</pubDate><guid>https://qrshxc.github.io/about/</guid><description>&lt;p&gt;A Hakurei Reimu style Hugo theme. Migrated from &lt;a href="https://github.com/qrshxc/qrshxc.github.io"&gt;hexo-theme-reimu&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>友情链接</title><link>https://qrshxc.github.io/friend/</link><pubDate>Fri, 04 Apr 2025 20:12:52 +0800</pubDate><guid>https://qrshxc.github.io/friend/</guid><description>&lt;h2 id="本站信息"&gt;
&lt;a class="header-anchor" href="#%e6%9c%ac%e7%ab%99%e4%bf%a1%e6%81%af"&gt;&lt;/a&gt;
本站信息
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;站名： &lt;a href="https://qrshxc.github.io/"&gt;https://qrshxc.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;站长： 九思&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="联系我们"&gt;
&lt;a class="header-anchor" href="#%e8%81%94%e7%b3%bb%e6%88%91%e4%bb%ac"&gt;&lt;/a&gt;
联系我们
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yml" data-lang="yml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="l"&gt;```yml&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;- &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;九思&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;https://www.cnblogs.com/qrshxc&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;email&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;qrhxc@163.com&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;desc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;博客园&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="l"&gt;```&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="小伙伴们"&gt;
&lt;a class="header-anchor" href="#%e5%b0%8f%e4%bc%99%e4%bc%b4%e4%bb%ac"&gt;&lt;/a&gt;
小伙伴们
&lt;/h2&gt;</description></item></channel></rss>